{"ast":null,"code":"/**\n * sifter.js\n * Copyright (c) 2013 Brian Reavis & contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this\n * file except in compliance with the License. You may obtain a copy of the License at:\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n * ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n *\n * @author Brian Reavis <brian@thirdroute.com>\n */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.Sifter = factory();\n  }\n})(this, function () {\n  /**\n   * Textually searches arrays and hashes of objects\n   * by property (or multiple properties). Designed\n   * specifically for autocomplete.\n   *\n   * @constructor\n   * @param {array|object} items\n   * @param {object} items\n   */\n  var Sifter = function (items, settings) {\n    this.items = items;\n    this.settings = settings || {\n      diacritics: true\n    };\n  };\n  /**\n   * Splits a search string into an array of individual\n   * regexps to be used to match results.\n   *\n   * @param {string} query\n   * @returns {array}\n   */\n\n\n  Sifter.prototype.tokenize = function (query) {\n    query = trim(String(query || '').toLowerCase());\n    if (!query || !query.length) return [];\n    var i, n, regex, letter;\n    var tokens = [];\n    var words = query.split(/ +/);\n\n    for (i = 0, n = words.length; i < n; i++) {\n      regex = escape_regex(words[i]);\n\n      if (this.settings.diacritics) {\n        for (letter in DIACRITICS) {\n          if (DIACRITICS.hasOwnProperty(letter)) {\n            regex = regex.replace(new RegExp(letter, 'g'), DIACRITICS[letter]);\n          }\n        }\n      }\n\n      tokens.push({\n        string: words[i],\n        regex: new RegExp(regex, 'i')\n      });\n    }\n\n    return tokens;\n  };\n  /**\n   * Iterates over arrays and hashes.\n   *\n   * ```\n   * this.iterator(this.items, function(item, id) {\n   *    // invoked for each item\n   * });\n   * ```\n   *\n   * @param {array|object} object\n   */\n\n\n  Sifter.prototype.iterator = function (object, callback) {\n    var iterator;\n\n    if (is_array(object)) {\n      iterator = Array.prototype.forEach || function (callback) {\n        for (var i = 0, n = this.length; i < n; i++) {\n          callback(this[i], i, this);\n        }\n      };\n    } else {\n      iterator = function (callback) {\n        for (var key in this) {\n          if (this.hasOwnProperty(key)) {\n            callback(this[key], key, this);\n          }\n        }\n      };\n    }\n\n    iterator.apply(object, [callback]);\n  };\n  /**\n   * Returns a function to be used to score individual results.\n   *\n   * Good matches will have a higher score than poor matches.\n   * If an item is not a match, 0 will be returned by the function.\n   *\n   * @param {object|string} search\n   * @param {object} options (optional)\n   * @returns {function}\n   */\n\n\n  Sifter.prototype.getScoreFunction = function (search, options) {\n    var self, fields, tokens, token_count, nesting;\n    self = this;\n    search = self.prepareSearch(search, options);\n    tokens = search.tokens;\n    fields = search.options.fields;\n    token_count = tokens.length;\n    nesting = search.options.nesting;\n    /**\n     * Calculates how close of a match the\n     * given value is against a search token.\n     *\n     * @param {mixed} value\n     * @param {object} token\n     * @return {number}\n     */\n\n    var scoreValue = function (value, token) {\n      var score, pos;\n      if (!value) return 0;\n      value = String(value || '');\n      pos = value.search(token.regex);\n      if (pos === -1) return 0;\n      score = token.string.length / value.length;\n      if (pos === 0) score += 0.5;\n      return score;\n    };\n    /**\n     * Calculates the score of an object\n     * against the search query.\n     *\n     * @param {object} token\n     * @param {object} data\n     * @return {number}\n     */\n\n\n    var scoreObject = function () {\n      var field_count = fields.length;\n\n      if (!field_count) {\n        return function () {\n          return 0;\n        };\n      }\n\n      if (field_count === 1) {\n        return function (token, data) {\n          return scoreValue(getattr(data, fields[0], nesting), token);\n        };\n      }\n\n      return function (token, data) {\n        for (var i = 0, sum = 0; i < field_count; i++) {\n          sum += scoreValue(getattr(data, fields[i], nesting), token);\n        }\n\n        return sum / field_count;\n      };\n    }();\n\n    if (!token_count) {\n      return function () {\n        return 0;\n      };\n    }\n\n    if (token_count === 1) {\n      return function (data) {\n        return scoreObject(tokens[0], data);\n      };\n    }\n\n    if (search.options.conjunction === 'and') {\n      return function (data) {\n        var score;\n\n        for (var i = 0, sum = 0; i < token_count; i++) {\n          score = scoreObject(tokens[i], data);\n          if (score <= 0) return 0;\n          sum += score;\n        }\n\n        return sum / token_count;\n      };\n    } else {\n      return function (data) {\n        for (var i = 0, sum = 0; i < token_count; i++) {\n          sum += scoreObject(tokens[i], data);\n        }\n\n        return sum / token_count;\n      };\n    }\n  };\n  /**\n   * Returns a function that can be used to compare two\n   * results, for sorting purposes. If no sorting should\n   * be performed, `null` will be returned.\n   *\n   * @param {string|object} search\n   * @param {object} options\n   * @return function(a,b)\n   */\n\n\n  Sifter.prototype.getSortFunction = function (search, options) {\n    var i, n, self, field, fields, fields_count, multiplier, multipliers, get_field, implicit_score, sort;\n    self = this;\n    search = self.prepareSearch(search, options);\n    sort = !search.query && options.sort_empty || options.sort;\n    /**\n     * Fetches the specified sort field value\n     * from a search result item.\n     *\n     * @param  {string} name\n     * @param  {object} result\n     * @return {mixed}\n     */\n\n    get_field = function (name, result) {\n      if (name === '$score') return result.score;\n      return getattr(self.items[result.id], name, options.nesting);\n    }; // parse options\n\n\n    fields = [];\n\n    if (sort) {\n      for (i = 0, n = sort.length; i < n; i++) {\n        if (search.query || sort[i].field !== '$score') {\n          fields.push(sort[i]);\n        }\n      }\n    } // the \"$score\" field is implied to be the primary\n    // sort field, unless it's manually specified\n\n\n    if (search.query) {\n      implicit_score = true;\n\n      for (i = 0, n = fields.length; i < n; i++) {\n        if (fields[i].field === '$score') {\n          implicit_score = false;\n          break;\n        }\n      }\n\n      if (implicit_score) {\n        fields.unshift({\n          field: '$score',\n          direction: 'desc'\n        });\n      }\n    } else {\n      for (i = 0, n = fields.length; i < n; i++) {\n        if (fields[i].field === '$score') {\n          fields.splice(i, 1);\n          break;\n        }\n      }\n    }\n\n    multipliers = [];\n\n    for (i = 0, n = fields.length; i < n; i++) {\n      multipliers.push(fields[i].direction === 'desc' ? -1 : 1);\n    } // build function\n\n\n    fields_count = fields.length;\n\n    if (!fields_count) {\n      return null;\n    } else if (fields_count === 1) {\n      field = fields[0].field;\n      multiplier = multipliers[0];\n      return function (a, b) {\n        return multiplier * cmp(get_field(field, a), get_field(field, b));\n      };\n    } else {\n      return function (a, b) {\n        var i, result, a_value, b_value, field;\n\n        for (i = 0; i < fields_count; i++) {\n          field = fields[i].field;\n          result = multipliers[i] * cmp(get_field(field, a), get_field(field, b));\n          if (result) return result;\n        }\n\n        return 0;\n      };\n    }\n  };\n  /**\n   * Parses a search query and returns an object\n   * with tokens and fields ready to be populated\n   * with results.\n   *\n   * @param {string} query\n   * @param {object} options\n   * @returns {object}\n   */\n\n\n  Sifter.prototype.prepareSearch = function (query, options) {\n    if (typeof query === 'object') return query;\n    options = extend({}, options);\n    var option_fields = options.fields;\n    var option_sort = options.sort;\n    var option_sort_empty = options.sort_empty;\n    if (option_fields && !is_array(option_fields)) options.fields = [option_fields];\n    if (option_sort && !is_array(option_sort)) options.sort = [option_sort];\n    if (option_sort_empty && !is_array(option_sort_empty)) options.sort_empty = [option_sort_empty];\n    return {\n      options: options,\n      query: String(query || '').toLowerCase(),\n      tokens: this.tokenize(query),\n      total: 0,\n      items: []\n    };\n  };\n  /**\n   * Searches through all items and returns a sorted array of matches.\n   *\n   * The `options` parameter can contain:\n   *\n   *   - fields {string|array}\n   *   - sort {array}\n   *   - score {function}\n   *   - filter {bool}\n   *   - limit {integer}\n   *\n   * Returns an object containing:\n   *\n   *   - options {object}\n   *   - query {string}\n   *   - tokens {array}\n   *   - total {int}\n   *   - items {array}\n   *\n   * @param {string} query\n   * @param {object} options\n   * @returns {object}\n   */\n\n\n  Sifter.prototype.search = function (query, options) {\n    var self = this,\n        value,\n        score,\n        search,\n        calculateScore;\n    var fn_sort;\n    var fn_score;\n    search = this.prepareSearch(query, options);\n    options = search.options;\n    query = search.query; // generate result scoring function\n\n    fn_score = options.score || self.getScoreFunction(search); // perform search and sort\n\n    if (query.length) {\n      self.iterator(self.items, function (item, id) {\n        score = fn_score(item);\n\n        if (options.filter === false || score > 0) {\n          search.items.push({\n            'score': score,\n            'id': id\n          });\n        }\n      });\n    } else {\n      self.iterator(self.items, function (item, id) {\n        search.items.push({\n          'score': 1,\n          'id': id\n        });\n      });\n    }\n\n    fn_sort = self.getSortFunction(search, options);\n    if (fn_sort) search.items.sort(fn_sort); // apply limits\n\n    search.total = search.items.length;\n\n    if (typeof options.limit === 'number') {\n      search.items = search.items.slice(0, options.limit);\n    }\n\n    return search;\n  }; // utilities\n  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\n  var cmp = function (a, b) {\n    if (typeof a === 'number' && typeof b === 'number') {\n      return a > b ? 1 : a < b ? -1 : 0;\n    }\n\n    a = asciifold(String(a || ''));\n    b = asciifold(String(b || ''));\n    if (a > b) return 1;\n    if (b > a) return -1;\n    return 0;\n  };\n\n  var extend = function (a, b) {\n    var i, n, k, object;\n\n    for (i = 1, n = arguments.length; i < n; i++) {\n      object = arguments[i];\n      if (!object) continue;\n\n      for (k in object) {\n        if (object.hasOwnProperty(k)) {\n          a[k] = object[k];\n        }\n      }\n    }\n\n    return a;\n  };\n  /**\n   * A property getter resolving dot-notation\n   * @param  {Object}  obj     The root object to fetch property on\n   * @param  {String}  name    The optionally dotted property name to fetch\n   * @param  {Boolean} nesting Handle nesting or not\n   * @return {Object}          The resolved property value\n   */\n\n\n  var getattr = function (obj, name, nesting) {\n    if (!obj || !name) return;\n    if (!nesting) return obj[name];\n    var names = name.split(\".\");\n\n    while (names.length && (obj = obj[names.shift()]));\n\n    return obj;\n  };\n\n  var trim = function (str) {\n    return (str + '').replace(/^\\s+|\\s+$|/g, '');\n  };\n\n  var escape_regex = function (str) {\n    return (str + '').replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n  };\n\n  var is_array = Array.isArray || typeof $ !== 'undefined' && $.isArray || function (object) {\n    return Object.prototype.toString.call(object) === '[object Array]';\n  };\n\n  var DIACRITICS = {\n    'a': '[aḀḁĂăÂâǍǎȺⱥȦȧẠạÄäÀàÁáĀāÃãÅåąĄÃąĄ]',\n    'b': '[b␢βΒB฿𐌁ᛒ]',\n    'c': '[cĆćĈĉČčĊċC̄c̄ÇçḈḉȻȼƇƈɕᴄＣｃ]',\n    'd': '[dĎďḊḋḐḑḌḍḒḓḎḏĐđD̦d̦ƉɖƊɗƋƌᵭᶁᶑȡᴅＤｄð]',\n    'e': '[eÉéÈèÊêḘḙĚěĔĕẼẽḚḛẺẻĖėËëĒēȨȩĘęᶒɆɇȄȅẾếỀềỄễỂểḜḝḖḗḔḕȆȇẸẹỆệⱸᴇＥｅɘǝƏƐε]',\n    'f': '[fƑƒḞḟ]',\n    'g': '[gɢ₲ǤǥĜĝĞğĢģƓɠĠġ]',\n    'h': '[hĤĥĦħḨḩẖẖḤḥḢḣɦʰǶƕ]',\n    'i': '[iÍíÌìĬĭÎîǏǐÏïḮḯĨĩĮįĪīỈỉȈȉȊȋỊịḬḭƗɨɨ̆ᵻᶖİiIıɪＩｉ]',\n    'j': '[jȷĴĵɈɉʝɟʲ]',\n    'k': '[kƘƙꝀꝁḰḱǨǩḲḳḴḵκϰ₭]',\n    'l': '[lŁłĽľĻļĹĺḶḷḸḹḼḽḺḻĿŀȽƚⱠⱡⱢɫɬᶅɭȴʟＬｌ]',\n    'n': '[nŃńǸǹŇňÑñṄṅŅņṆṇṊṋṈṉN̈n̈ƝɲȠƞᵰᶇɳȵɴＮｎŊŋ]',\n    'o': '[oØøÖöÓóÒòÔôǑǒŐőŎŏȮȯỌọƟɵƠơỎỏŌōÕõǪǫȌȍՕօ]',\n    'p': '[pṔṕṖṗⱣᵽƤƥᵱ]',\n    'q': '[qꝖꝗʠɊɋꝘꝙq̃]',\n    'r': '[rŔŕɌɍŘřŖŗṘṙȐȑȒȓṚṛⱤɽ]',\n    's': '[sŚśṠṡṢṣꞨꞩŜŝŠšŞşȘșS̈s̈]',\n    't': '[tŤťṪṫŢţṬṭƮʈȚțṰṱṮṯƬƭ]',\n    'u': '[uŬŭɄʉỤụÜüÚúÙùÛûǓǔŰűŬŭƯưỦủŪūŨũŲųȔȕ∪]',\n    'v': '[vṼṽṾṿƲʋꝞꝟⱱʋ]',\n    'w': '[wẂẃẀẁŴŵẄẅẆẇẈẉ]',\n    'x': '[xẌẍẊẋχ]',\n    'y': '[yÝýỲỳŶŷŸÿỸỹẎẏỴỵɎɏƳƴ]',\n    'z': '[zŹźẐẑŽžŻżẒẓẔẕƵƶ]'\n  };\n\n  var asciifold = function () {\n    var i, n, k, chunk;\n    var foreignletters = '';\n    var lookup = {};\n\n    for (k in DIACRITICS) {\n      if (DIACRITICS.hasOwnProperty(k)) {\n        chunk = DIACRITICS[k].substring(2, DIACRITICS[k].length - 1);\n        foreignletters += chunk;\n\n        for (i = 0, n = chunk.length; i < n; i++) {\n          lookup[chunk.charAt(i)] = k;\n        }\n      }\n    }\n\n    var regexp = new RegExp('[' + foreignletters + ']', 'g');\n    return function (str) {\n      return str.replace(regexp, function (foreignletter) {\n        return lookup[foreignletter];\n      }).toLowerCase();\n    };\n  }(); // export\n  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\n  return Sifter;\n});","map":null,"metadata":{},"sourceType":"script"}