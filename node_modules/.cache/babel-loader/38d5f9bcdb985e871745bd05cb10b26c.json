{"ast":null,"code":"/**\n * selectize.js (v0.12.6)\n * Copyright (c) 2013â€“2015 Brian Reavis & contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this\n * file except in compliance with the License. You may obtain a copy of the License at:\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n * ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n *\n * @author Brian Reavis <brian@thirdroute.com>\n */\n\n/*jshint curly:false */\n\n/*jshint browser:true */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['jquery', 'sifter', 'microplugin'], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory(require('jquery'), require('sifter'), require('microplugin'));\n  } else {\n    root.Selectize = factory(root.jQuery, root.Sifter, root.MicroPlugin);\n  }\n})(this, function ($, Sifter, MicroPlugin) {\n  'use strict';\n\n  var highlight = function ($element, pattern) {\n    if (typeof pattern === 'string' && !pattern.length) return;\n    var regex = typeof pattern === 'string' ? new RegExp(pattern, 'i') : pattern;\n\n    var highlight = function (node) {\n      var skip = 0; // Wrap matching part of text node with highlighting <span>, e.g.\n      // Soccer  ->  <span class=\"highlight\">Soc</span>cer  for regex = /soc/i\n\n      if (node.nodeType === 3) {\n        var pos = node.data.search(regex);\n\n        if (pos >= 0 && node.data.length > 0) {\n          var match = node.data.match(regex);\n          var spannode = document.createElement('span');\n          spannode.className = 'highlight';\n          var middlebit = node.splitText(pos);\n          var endbit = middlebit.splitText(match[0].length);\n          var middleclone = middlebit.cloneNode(true);\n          spannode.appendChild(middleclone);\n          middlebit.parentNode.replaceChild(spannode, middlebit);\n          skip = 1;\n        }\n      } // Recurse element node, looking for child text nodes to highlight, unless element \n      // is childless, <script>, <style>, or already highlighted: <span class=\"hightlight\">\n      else if (node.nodeType === 1 && node.childNodes && !/(script|style)/i.test(node.tagName) && (node.className !== 'highlight' || node.tagName !== 'SPAN')) {\n          for (var i = 0; i < node.childNodes.length; ++i) {\n            i += highlight(node.childNodes[i]);\n          }\n        }\n\n      return skip;\n    };\n\n    return $element.each(function () {\n      highlight(this);\n    });\n  };\n  /**\n   * removeHighlight fn copied from highlight v5 and\n   * edited to remove with() and pass js strict mode\n   */\n\n\n  $.fn.removeHighlight = function () {\n    return this.find(\"span.highlight\").each(function () {\n      this.parentNode.firstChild.nodeName;\n      var parent = this.parentNode;\n      parent.replaceChild(this.firstChild, this);\n      parent.normalize();\n    }).end();\n  };\n\n  var MicroEvent = function () {};\n\n  MicroEvent.prototype = {\n    on: function (event, fct) {\n      this._events = this._events || {};\n      this._events[event] = this._events[event] || [];\n\n      this._events[event].push(fct);\n    },\n    off: function (event, fct) {\n      var n = arguments.length;\n      if (n === 0) return delete this._events;\n      if (n === 1) return delete this._events[event];\n      this._events = this._events || {};\n      if (event in this._events === false) return;\n\n      this._events[event].splice(this._events[event].indexOf(fct), 1);\n    },\n    trigger: function (event\n    /* , args... */\n    ) {\n      this._events = this._events || {};\n      if (event in this._events === false) return;\n\n      for (var i = 0; i < this._events[event].length; i++) {\n        this._events[event][i].apply(this, Array.prototype.slice.call(arguments, 1));\n      }\n    }\n  };\n  /**\n   * Mixin will delegate all MicroEvent.js function in the destination object.\n   *\n   * - MicroEvent.mixin(Foobar) will make Foobar able to use MicroEvent\n   *\n   * @param {object} the object which will support MicroEvent\n   */\n\n  MicroEvent.mixin = function (destObject) {\n    var props = ['on', 'off', 'trigger'];\n\n    for (var i = 0; i < props.length; i++) {\n      destObject.prototype[props[i]] = MicroEvent.prototype[props[i]];\n    }\n  };\n\n  var IS_MAC = /Mac/.test(navigator.userAgent);\n  var KEY_A = 65;\n  var KEY_COMMA = 188;\n  var KEY_RETURN = 13;\n  var KEY_ESC = 27;\n  var KEY_LEFT = 37;\n  var KEY_UP = 38;\n  var KEY_P = 80;\n  var KEY_RIGHT = 39;\n  var KEY_DOWN = 40;\n  var KEY_N = 78;\n  var KEY_BACKSPACE = 8;\n  var KEY_DELETE = 46;\n  var KEY_SHIFT = 16;\n  var KEY_CMD = IS_MAC ? 91 : 17;\n  var KEY_CTRL = IS_MAC ? 18 : 17;\n  var KEY_TAB = 9;\n  var TAG_SELECT = 1;\n  var TAG_INPUT = 2; // for now, android support in general is too spotty to support validity\n\n  var SUPPORTS_VALIDITY_API = !/android/i.test(window.navigator.userAgent) && !!document.createElement('input').validity;\n\n  var isset = function (object) {\n    return typeof object !== 'undefined';\n  };\n  /**\n   * Converts a scalar to its best string representation\n   * for hash keys and HTML attribute values.\n   *\n   * Transformations:\n   *   'str'     -> 'str'\n   *   null      -> ''\n   *   undefined -> ''\n   *   true      -> '1'\n   *   false     -> '0'\n   *   0         -> '0'\n   *   1         -> '1'\n   *\n   * @param {string} value\n   * @returns {string|null}\n   */\n\n\n  var hash_key = function (value) {\n    if (typeof value === 'undefined' || value === null) return null;\n    if (typeof value === 'boolean') return value ? '1' : '0';\n    return value + '';\n  };\n  /**\n   * Escapes a string for use within HTML.\n   *\n   * @param {string} str\n   * @returns {string}\n   */\n\n\n  var escape_html = function (str) {\n    return (str + '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;');\n  };\n  /**\n   * Escapes \"$\" characters in replacement strings.\n   *\n   * @param {string} str\n   * @returns {string}\n   */\n\n\n  var escape_replace = function (str) {\n    return (str + '').replace(/\\$/g, '$$$$');\n  };\n\n  var hook = {};\n  /**\n   * Wraps `method` on `self` so that `fn`\n   * is invoked before the original method.\n   *\n   * @param {object} self\n   * @param {string} method\n   * @param {function} fn\n   */\n\n  hook.before = function (self, method, fn) {\n    var original = self[method];\n\n    self[method] = function () {\n      fn.apply(self, arguments);\n      return original.apply(self, arguments);\n    };\n  };\n  /**\n   * Wraps `method` on `self` so that `fn`\n   * is invoked after the original method.\n   *\n   * @param {object} self\n   * @param {string} method\n   * @param {function} fn\n   */\n\n\n  hook.after = function (self, method, fn) {\n    var original = self[method];\n\n    self[method] = function () {\n      var result = original.apply(self, arguments);\n      fn.apply(self, arguments);\n      return result;\n    };\n  };\n  /**\n   * Wraps `fn` so that it can only be invoked once.\n   *\n   * @param {function} fn\n   * @returns {function}\n   */\n\n\n  var once = function (fn) {\n    var called = false;\n    return function () {\n      if (called) return;\n      called = true;\n      fn.apply(this, arguments);\n    };\n  };\n  /**\n   * Wraps `fn` so that it can only be called once\n   * every `delay` milliseconds (invoked on the falling edge).\n   *\n   * @param {function} fn\n   * @param {int} delay\n   * @returns {function}\n   */\n\n\n  var debounce = function (fn, delay) {\n    var timeout;\n    return function () {\n      var self = this;\n      var args = arguments;\n      window.clearTimeout(timeout);\n      timeout = window.setTimeout(function () {\n        fn.apply(self, args);\n      }, delay);\n    };\n  };\n  /**\n   * Debounce all fired events types listed in `types`\n   * while executing the provided `fn`.\n   *\n   * @param {object} self\n   * @param {array} types\n   * @param {function} fn\n   */\n\n\n  var debounce_events = function (self, types, fn) {\n    var type;\n    var trigger = self.trigger;\n    var event_args = {}; // override trigger method\n\n    self.trigger = function () {\n      var type = arguments[0];\n\n      if (types.indexOf(type) !== -1) {\n        event_args[type] = arguments;\n      } else {\n        return trigger.apply(self, arguments);\n      }\n    }; // invoke provided function\n\n\n    fn.apply(self, []);\n    self.trigger = trigger; // trigger queued events\n\n    for (type in event_args) {\n      if (event_args.hasOwnProperty(type)) {\n        trigger.apply(self, event_args[type]);\n      }\n    }\n  };\n  /**\n   * A workaround for http://bugs.jquery.com/ticket/6696\n   *\n   * @param {object} $parent - Parent element to listen on.\n   * @param {string} event - Event name.\n   * @param {string} selector - Descendant selector to filter by.\n   * @param {function} fn - Event handler.\n   */\n\n\n  var watchChildEvent = function ($parent, event, selector, fn) {\n    $parent.on(event, selector, function (e) {\n      var child = e.target;\n\n      while (child && child.parentNode !== $parent[0]) {\n        child = child.parentNode;\n      }\n\n      e.currentTarget = child;\n      return fn.apply(this, [e]);\n    });\n  };\n  /**\n   * Determines the current selection within a text input control.\n   * Returns an object containing:\n   *   - start\n   *   - length\n   *\n   * @param {object} input\n   * @returns {object}\n   */\n\n\n  var getSelection = function (input) {\n    var result = {};\n\n    if ('selectionStart' in input) {\n      result.start = input.selectionStart;\n      result.length = input.selectionEnd - result.start;\n    } else if (document.selection) {\n      input.focus();\n      var sel = document.selection.createRange();\n      var selLen = document.selection.createRange().text.length;\n      sel.moveStart('character', -input.value.length);\n      result.start = sel.text.length - selLen;\n      result.length = selLen;\n    }\n\n    return result;\n  };\n  /**\n   * Copies CSS properties from one element to another.\n   *\n   * @param {object} $from\n   * @param {object} $to\n   * @param {array} properties\n   */\n\n\n  var transferStyles = function ($from, $to, properties) {\n    var i,\n        n,\n        styles = {};\n\n    if (properties) {\n      for (i = 0, n = properties.length; i < n; i++) {\n        styles[properties[i]] = $from.css(properties[i]);\n      }\n    } else {\n      styles = $from.css();\n    }\n\n    $to.css(styles);\n  };\n  /**\n   * Measures the width of a string within a\n   * parent element (in pixels).\n   *\n   * @param {string} str\n   * @param {object} $parent\n   * @returns {int}\n   */\n\n\n  var measureString = function (str, $parent) {\n    if (!str) {\n      return 0;\n    }\n\n    if (!Selectize.$testInput) {\n      Selectize.$testInput = $('<span />').css({\n        position: 'absolute',\n        top: -99999,\n        left: -99999,\n        width: 'auto',\n        padding: 0,\n        whiteSpace: 'pre'\n      }).appendTo('body');\n    }\n\n    Selectize.$testInput.text(str);\n    transferStyles($parent, Selectize.$testInput, ['letterSpacing', 'fontSize', 'fontFamily', 'fontWeight', 'textTransform']);\n    return Selectize.$testInput.width();\n  };\n  /**\n   * Sets up an input to grow horizontally as the user\n   * types. If the value is changed manually, you can\n   * trigger the \"update\" handler to resize:\n   *\n   * $input.trigger('update');\n   *\n   * @param {object} $input\n   */\n\n\n  var autoGrow = function ($input) {\n    var currentWidth = null;\n\n    var update = function (e, options) {\n      var value, keyCode, printable, placeholder, width;\n      var shift, character, selection;\n      e = e || window.event || {};\n      options = options || {};\n      if (e.metaKey || e.altKey) return;\n      if (!options.force && $input.data('grow') === false) return;\n      value = $input.val();\n\n      if (e.type && e.type.toLowerCase() === 'keydown') {\n        keyCode = e.keyCode;\n        printable = keyCode >= 48 && keyCode <= 57 || // 0-9\n        keyCode >= 65 && keyCode <= 90 || // a-z\n        keyCode >= 96 && keyCode <= 111 || // numpad 0-9, numeric operators\n        keyCode >= 186 && keyCode <= 222 || // semicolon, equal, comma, dash, etc.\n        keyCode === 32 // space\n        ;\n\n        if (keyCode === KEY_DELETE || keyCode === KEY_BACKSPACE) {\n          selection = getSelection($input[0]);\n\n          if (selection.length) {\n            value = value.substring(0, selection.start) + value.substring(selection.start + selection.length);\n          } else if (keyCode === KEY_BACKSPACE && selection.start) {\n            value = value.substring(0, selection.start - 1) + value.substring(selection.start + 1);\n          } else if (keyCode === KEY_DELETE && typeof selection.start !== 'undefined') {\n            value = value.substring(0, selection.start) + value.substring(selection.start + 1);\n          }\n        } else if (printable) {\n          shift = e.shiftKey;\n          character = String.fromCharCode(e.keyCode);\n          if (shift) character = character.toUpperCase();else character = character.toLowerCase();\n          value += character;\n        }\n      }\n\n      placeholder = $input.attr('placeholder');\n\n      if (!value && placeholder) {\n        value = placeholder;\n      }\n\n      width = measureString(value, $input) + 4;\n\n      if (width !== currentWidth) {\n        currentWidth = width;\n        $input.width(width);\n        $input.triggerHandler('resize');\n      }\n    };\n\n    $input.on('keydown keyup update blur', update);\n    update();\n  };\n\n  var domToString = function (d) {\n    var tmp = document.createElement('div');\n    tmp.appendChild(d.cloneNode(true));\n    return tmp.innerHTML;\n  };\n\n  var logError = function (message, options) {\n    if (!options) options = {};\n    var component = \"Selectize\";\n    console.error(component + \": \" + message);\n\n    if (options.explanation) {\n      // console.group is undefined in <IE11\n      if (console.group) console.group();\n      console.error(options.explanation);\n      if (console.group) console.groupEnd();\n    }\n  };\n\n  var Selectize = function ($input, settings) {\n    var key,\n        i,\n        n,\n        dir,\n        input,\n        self = this;\n    input = $input[0];\n    input.selectize = self; // detect rtl environment\n\n    var computedStyle = window.getComputedStyle && window.getComputedStyle(input, null);\n    dir = computedStyle ? computedStyle.getPropertyValue('direction') : input.currentStyle && input.currentStyle.direction;\n    dir = dir || $input.parents('[dir]:first').attr('dir') || ''; // setup default state\n\n    $.extend(self, {\n      order: 0,\n      settings: settings,\n      $input: $input,\n      tabIndex: $input.attr('tabindex') || '',\n      tagType: input.tagName.toLowerCase() === 'select' ? TAG_SELECT : TAG_INPUT,\n      rtl: /rtl/i.test(dir),\n      eventNS: '.selectize' + ++Selectize.count,\n      highlightedValue: null,\n      isBlurring: false,\n      isOpen: false,\n      isDisabled: false,\n      isRequired: $input.is('[required]'),\n      isInvalid: false,\n      isLocked: false,\n      isFocused: false,\n      isInputHidden: false,\n      isSetup: false,\n      isShiftDown: false,\n      isCmdDown: false,\n      isCtrlDown: false,\n      ignoreFocus: false,\n      ignoreBlur: false,\n      ignoreHover: false,\n      hasOptions: false,\n      currentResults: null,\n      lastValue: '',\n      caretPos: 0,\n      loading: 0,\n      loadedSearches: {},\n      $activeOption: null,\n      $activeItems: [],\n      optgroups: {},\n      options: {},\n      userOptions: {},\n      items: [],\n      renderCache: {},\n      onSearchChange: settings.loadThrottle === null ? self.onSearchChange : debounce(self.onSearchChange, settings.loadThrottle)\n    }); // search system\n\n    self.sifter = new Sifter(this.options, {\n      diacritics: settings.diacritics\n    }); // build options table\n\n    if (self.settings.options) {\n      for (i = 0, n = self.settings.options.length; i < n; i++) {\n        self.registerOption(self.settings.options[i]);\n      }\n\n      delete self.settings.options;\n    } // build optgroup table\n\n\n    if (self.settings.optgroups) {\n      for (i = 0, n = self.settings.optgroups.length; i < n; i++) {\n        self.registerOptionGroup(self.settings.optgroups[i]);\n      }\n\n      delete self.settings.optgroups;\n    } // option-dependent defaults\n\n\n    self.settings.mode = self.settings.mode || (self.settings.maxItems === 1 ? 'single' : 'multi');\n\n    if (typeof self.settings.hideSelected !== 'boolean') {\n      self.settings.hideSelected = self.settings.mode === 'multi';\n    }\n\n    self.initializePlugins(self.settings.plugins);\n    self.setupCallbacks();\n    self.setupTemplates();\n    self.setup();\n  }; // mixins\n  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\n  MicroEvent.mixin(Selectize);\n\n  if (typeof MicroPlugin !== \"undefined\") {\n    MicroPlugin.mixin(Selectize);\n  } else {\n    logError(\"Dependency MicroPlugin is missing\", {\n      explanation: \"Make sure you either: (1) are using the \\\"standalone\\\" \" + \"version of Selectize, or (2) require MicroPlugin before you \" + \"load Selectize.\"\n    });\n  } // methods\n  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\n  $.extend(Selectize.prototype, {\n    /**\n     * Creates all elements and sets up event bindings.\n     */\n    setup: function () {\n      var self = this;\n      var settings = self.settings;\n      var eventNS = self.eventNS;\n      var $window = $(window);\n      var $document = $(document);\n      var $input = self.$input;\n      var $wrapper;\n      var $control;\n      var $control_input;\n      var $dropdown;\n      var $dropdown_content;\n      var $dropdown_parent;\n      var inputMode;\n      var timeout_blur;\n      var timeout_focus;\n      var classes;\n      var classes_plugins;\n      var inputId;\n      inputMode = self.settings.mode;\n      classes = $input.attr('class') || '';\n      $wrapper = $('<div>').addClass(settings.wrapperClass).addClass(classes).addClass(inputMode);\n      $control = $('<div>').addClass(settings.inputClass).addClass('items').appendTo($wrapper);\n      $control_input = $('<input type=\"text\" autocomplete=\"off\" />').appendTo($control).attr('tabindex', $input.is(':disabled') ? '-1' : self.tabIndex);\n      $dropdown_parent = $(settings.dropdownParent || $wrapper);\n      $dropdown = $('<div>').addClass(settings.dropdownClass).addClass(inputMode).hide().appendTo($dropdown_parent);\n      $dropdown_content = $('<div>').addClass(settings.dropdownContentClass).appendTo($dropdown);\n\n      if (inputId = $input.attr('id')) {\n        $control_input.attr('id', inputId + '-selectized');\n        $(\"label[for='\" + inputId + \"']\").attr('for', inputId + '-selectized');\n      }\n\n      if (self.settings.copyClassesToDropdown) {\n        $dropdown.addClass(classes);\n      }\n\n      $wrapper.css({\n        width: $input[0].style.width\n      });\n\n      if (self.plugins.names.length) {\n        classes_plugins = 'plugin-' + self.plugins.names.join(' plugin-');\n        $wrapper.addClass(classes_plugins);\n        $dropdown.addClass(classes_plugins);\n      }\n\n      if ((settings.maxItems === null || settings.maxItems > 1) && self.tagType === TAG_SELECT) {\n        $input.attr('multiple', 'multiple');\n      }\n\n      if (self.settings.placeholder) {\n        $control_input.attr('placeholder', settings.placeholder);\n      } // if splitOn was not passed in, construct it from the delimiter to allow pasting universally\n\n\n      if (!self.settings.splitOn && self.settings.delimiter) {\n        var delimiterEscaped = self.settings.delimiter.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n        self.settings.splitOn = new RegExp('\\\\s*' + delimiterEscaped + '+\\\\s*');\n      }\n\n      if ($input.attr('autocorrect')) {\n        $control_input.attr('autocorrect', $input.attr('autocorrect'));\n      }\n\n      if ($input.attr('autocapitalize')) {\n        $control_input.attr('autocapitalize', $input.attr('autocapitalize'));\n      }\n\n      $control_input[0].type = $input[0].type;\n      self.$wrapper = $wrapper;\n      self.$control = $control;\n      self.$control_input = $control_input;\n      self.$dropdown = $dropdown;\n      self.$dropdown_content = $dropdown_content;\n      $dropdown.on('mouseenter mousedown click', '[data-disabled]>[data-selectable]', function (e) {\n        e.stopImmediatePropagation();\n      });\n      $dropdown.on('mouseenter', '[data-selectable]', function () {\n        return self.onOptionHover.apply(self, arguments);\n      });\n      $dropdown.on('mousedown click', '[data-selectable]', function () {\n        return self.onOptionSelect.apply(self, arguments);\n      });\n      watchChildEvent($control, 'mousedown', '*:not(input)', function () {\n        return self.onItemSelect.apply(self, arguments);\n      });\n      autoGrow($control_input);\n      $control.on({\n        mousedown: function () {\n          return self.onMouseDown.apply(self, arguments);\n        },\n        click: function () {\n          return self.onClick.apply(self, arguments);\n        }\n      });\n      $control_input.on({\n        mousedown: function (e) {\n          e.stopPropagation();\n        },\n        keydown: function () {\n          return self.onKeyDown.apply(self, arguments);\n        },\n        keyup: function () {\n          return self.onKeyUp.apply(self, arguments);\n        },\n        keypress: function () {\n          return self.onKeyPress.apply(self, arguments);\n        },\n        resize: function () {\n          self.positionDropdown.apply(self, []);\n        },\n        blur: function () {\n          return self.onBlur.apply(self, arguments);\n        },\n        focus: function () {\n          self.ignoreBlur = false;\n          return self.onFocus.apply(self, arguments);\n        },\n        paste: function () {\n          return self.onPaste.apply(self, arguments);\n        }\n      });\n      $document.on('keydown' + eventNS, function (e) {\n        self.isCmdDown = e[IS_MAC ? 'metaKey' : 'ctrlKey'];\n        self.isCtrlDown = e[IS_MAC ? 'altKey' : 'ctrlKey'];\n        self.isShiftDown = e.shiftKey;\n      });\n      $document.on('keyup' + eventNS, function (e) {\n        if (e.keyCode === KEY_CTRL) self.isCtrlDown = false;\n        if (e.keyCode === KEY_SHIFT) self.isShiftDown = false;\n        if (e.keyCode === KEY_CMD) self.isCmdDown = false;\n      });\n      $document.on('mousedown' + eventNS, function (e) {\n        if (self.isFocused) {\n          // prevent events on the dropdown scrollbar from causing the control to blur\n          if (e.target === self.$dropdown[0] || e.target.parentNode === self.$dropdown[0]) {\n            return false;\n          } // blur on click outside\n\n\n          if (!self.$control.has(e.target).length && e.target !== self.$control[0]) {\n            self.blur(e.target);\n          }\n        }\n      });\n      $window.on(['scroll' + eventNS, 'resize' + eventNS].join(' '), function () {\n        if (self.isOpen) {\n          self.positionDropdown.apply(self, arguments);\n        }\n      });\n      $window.on('mousemove' + eventNS, function () {\n        self.ignoreHover = false;\n      }); // store original children and tab index so that they can be\n      // restored when the destroy() method is called.\n\n      this.revertSettings = {\n        $children: $input.children().detach(),\n        tabindex: $input.attr('tabindex')\n      };\n      $input.attr('tabindex', -1).hide().after(self.$wrapper);\n\n      if ($.isArray(settings.items)) {\n        self.setValue(settings.items);\n        delete settings.items;\n      } // feature detect for the validation API\n\n\n      if (SUPPORTS_VALIDITY_API) {\n        $input.on('invalid' + eventNS, function (e) {\n          e.preventDefault();\n          self.isInvalid = true;\n          self.refreshState();\n        });\n      }\n\n      self.updateOriginalInput();\n      self.refreshItems();\n      self.refreshState();\n      self.updatePlaceholder();\n      self.isSetup = true;\n\n      if ($input.is(':disabled')) {\n        self.disable();\n      }\n\n      self.on('change', this.onChange);\n      $input.data('selectize', self);\n      $input.addClass('selectized');\n      self.trigger('initialize'); // preload options\n\n      if (settings.preload === true) {\n        self.onSearchChange('');\n      }\n    },\n\n    /**\n     * Sets up default rendering functions.\n     */\n    setupTemplates: function () {\n      var self = this;\n      var field_label = self.settings.labelField;\n      var field_optgroup = self.settings.optgroupLabelField;\n      var templates = {\n        'optgroup': function (data) {\n          return '<div class=\"optgroup\">' + data.html + '</div>';\n        },\n        'optgroup_header': function (data, escape) {\n          return '<div class=\"optgroup-header\">' + escape(data[field_optgroup]) + '</div>';\n        },\n        'option': function (data, escape) {\n          return '<div class=\"option\">' + escape(data[field_label]) + '</div>';\n        },\n        'item': function (data, escape) {\n          return '<div class=\"item\">' + escape(data[field_label]) + '</div>';\n        },\n        'option_create': function (data, escape) {\n          return '<div class=\"create\">Add <strong>' + escape(data.input) + '</strong>&hellip;</div>';\n        }\n      };\n      self.settings.render = $.extend({}, templates, self.settings.render);\n    },\n\n    /**\n     * Maps fired events to callbacks provided\n     * in the settings used when creating the control.\n     */\n    setupCallbacks: function () {\n      var key,\n          fn,\n          callbacks = {\n        'initialize': 'onInitialize',\n        'change': 'onChange',\n        'item_add': 'onItemAdd',\n        'item_remove': 'onItemRemove',\n        'clear': 'onClear',\n        'option_add': 'onOptionAdd',\n        'option_remove': 'onOptionRemove',\n        'option_clear': 'onOptionClear',\n        'optgroup_add': 'onOptionGroupAdd',\n        'optgroup_remove': 'onOptionGroupRemove',\n        'optgroup_clear': 'onOptionGroupClear',\n        'dropdown_open': 'onDropdownOpen',\n        'dropdown_close': 'onDropdownClose',\n        'type': 'onType',\n        'load': 'onLoad',\n        'focus': 'onFocus',\n        'blur': 'onBlur'\n      };\n\n      for (key in callbacks) {\n        if (callbacks.hasOwnProperty(key)) {\n          fn = this.settings[callbacks[key]];\n          if (fn) this.on(key, fn);\n        }\n      }\n    },\n\n    /**\n     * Triggered when the main control element\n     * has a click event.\n     *\n     * @param {object} e\n     * @return {boolean}\n     */\n    onClick: function (e) {\n      var self = this; // necessary for mobile webkit devices (manual focus triggering\n      // is ignored unless invoked within a click event)\n      // also necessary to reopen a dropdown that has been closed by\n      // closeAfterSelect\n\n      if (!self.isFocused || !self.isOpen) {\n        self.focus();\n        e.preventDefault();\n      }\n    },\n\n    /**\n     * Triggered when the main control element\n     * has a mouse down event.\n     *\n     * @param {object} e\n     * @return {boolean}\n     */\n    onMouseDown: function (e) {\n      var self = this;\n      var defaultPrevented = e.isDefaultPrevented();\n      var $target = $(e.target);\n\n      if (self.isFocused) {\n        // retain focus by preventing native handling. if the\n        // event target is the input it should not be modified.\n        // otherwise, text selection within the input won't work.\n        if (e.target !== self.$control_input[0]) {\n          if (self.settings.mode === 'single') {\n            // toggle dropdown\n            self.isOpen ? self.close() : self.open();\n          } else if (!defaultPrevented) {\n            self.setActiveItem(null);\n          }\n\n          return false;\n        }\n      } else {\n        // give control focus\n        if (!defaultPrevented) {\n          window.setTimeout(function () {\n            self.focus();\n          }, 0);\n        }\n      }\n    },\n\n    /**\n     * Triggered when the value of the control has been changed.\n     * This should propagate the event to the original DOM\n     * input / select element.\n     */\n    onChange: function () {\n      this.$input.trigger('change');\n    },\n\n    /**\n     * Triggered on <input> paste.\n     *\n     * @param {object} e\n     * @returns {boolean}\n     */\n    onPaste: function (e) {\n      var self = this;\n\n      if (self.isFull() || self.isInputHidden || self.isLocked) {\n        e.preventDefault();\n        return;\n      } // If a regex or string is included, this will split the pasted\n      // input and create Items for each separate value\n\n\n      if (self.settings.splitOn) {\n        // Wait for pasted text to be recognized in value\n        setTimeout(function () {\n          var pastedText = self.$control_input.val();\n\n          if (!pastedText.match(self.settings.splitOn)) {\n            return;\n          }\n\n          var splitInput = $.trim(pastedText).split(self.settings.splitOn);\n\n          for (var i = 0, n = splitInput.length; i < n; i++) {\n            self.createItem(splitInput[i]);\n          }\n        }, 0);\n      }\n    },\n\n    /**\n     * Triggered on <input> keypress.\n     *\n     * @param {object} e\n     * @returns {boolean}\n     */\n    onKeyPress: function (e) {\n      if (this.isLocked) return e && e.preventDefault();\n      var character = String.fromCharCode(e.keyCode || e.which);\n\n      if (this.settings.create && this.settings.mode === 'multi' && character === this.settings.delimiter) {\n        this.createItem();\n        e.preventDefault();\n        return false;\n      }\n    },\n\n    /**\n     * Triggered on <input> keydown.\n     *\n     * @param {object} e\n     * @returns {boolean}\n     */\n    onKeyDown: function (e) {\n      var isInput = e.target === this.$control_input[0];\n      var self = this;\n\n      if (self.isLocked) {\n        if (e.keyCode !== KEY_TAB) {\n          e.preventDefault();\n        }\n\n        return;\n      }\n\n      switch (e.keyCode) {\n        case KEY_A:\n          if (self.isCmdDown) {\n            self.selectAll();\n            return;\n          }\n\n          break;\n\n        case KEY_ESC:\n          if (self.isOpen) {\n            e.preventDefault();\n            e.stopPropagation();\n            self.close();\n          }\n\n          return;\n\n        case KEY_N:\n          if (!e.ctrlKey || e.altKey) break;\n\n        case KEY_DOWN:\n          if (!self.isOpen && self.hasOptions) {\n            self.open();\n          } else if (self.$activeOption) {\n            self.ignoreHover = true;\n            var $next = self.getAdjacentOption(self.$activeOption, 1);\n            if ($next.length) self.setActiveOption($next, true, true);\n          }\n\n          e.preventDefault();\n          return;\n\n        case KEY_P:\n          if (!e.ctrlKey || e.altKey) break;\n\n        case KEY_UP:\n          if (self.$activeOption) {\n            self.ignoreHover = true;\n            var $prev = self.getAdjacentOption(self.$activeOption, -1);\n            if ($prev.length) self.setActiveOption($prev, true, true);\n          }\n\n          e.preventDefault();\n          return;\n\n        case KEY_RETURN:\n          if (self.isOpen && self.$activeOption) {\n            self.onOptionSelect({\n              currentTarget: self.$activeOption\n            });\n            e.preventDefault();\n          }\n\n          return;\n\n        case KEY_LEFT:\n          self.advanceSelection(-1, e);\n          return;\n\n        case KEY_RIGHT:\n          self.advanceSelection(1, e);\n          return;\n\n        case KEY_TAB:\n          if (self.settings.selectOnTab && self.isOpen && self.$activeOption) {\n            self.onOptionSelect({\n              currentTarget: self.$activeOption\n            }); // Default behaviour is to jump to the next field, we only want this\n            // if the current field doesn't accept any more entries\n\n            if (!self.isFull()) {\n              e.preventDefault();\n            }\n          }\n\n          if (self.settings.create && self.createItem()) {\n            e.preventDefault();\n          }\n\n          return;\n\n        case KEY_BACKSPACE:\n        case KEY_DELETE:\n          self.deleteSelection(e);\n          return;\n      }\n\n      if ((self.isFull() || self.isInputHidden) && !(IS_MAC ? e.metaKey : e.ctrlKey)) {\n        e.preventDefault();\n        return;\n      }\n    },\n\n    /**\n     * Triggered on <input> keyup.\n     *\n     * @param {object} e\n     * @returns {boolean}\n     */\n    onKeyUp: function (e) {\n      var self = this;\n      if (self.isLocked) return e && e.preventDefault();\n      var value = self.$control_input.val() || '';\n\n      if (self.lastValue !== value) {\n        self.lastValue = value;\n        self.onSearchChange(value);\n        self.refreshOptions();\n        self.trigger('type', value);\n      }\n    },\n\n    /**\n     * Invokes the user-provide option provider / loader.\n     *\n     * Note: this function is debounced in the Selectize\n     * constructor (by `settings.loadThrottle` milliseconds)\n     *\n     * @param {string} value\n     */\n    onSearchChange: function (value) {\n      var self = this;\n      var fn = self.settings.load;\n      if (!fn) return;\n      if (self.loadedSearches.hasOwnProperty(value)) return;\n      self.loadedSearches[value] = true;\n      self.load(function (callback) {\n        fn.apply(self, [value, callback]);\n      });\n    },\n\n    /**\n     * Triggered on <input> focus.\n     *\n     * @param {object} e (optional)\n     * @returns {boolean}\n     */\n    onFocus: function (e) {\n      var self = this;\n      var wasFocused = self.isFocused;\n\n      if (self.isDisabled) {\n        self.blur();\n        e && e.preventDefault();\n        return false;\n      }\n\n      if (self.ignoreFocus) return;\n      self.isFocused = true;\n      if (self.settings.preload === 'focus') self.onSearchChange('');\n      if (!wasFocused) self.trigger('focus');\n\n      if (!self.$activeItems.length) {\n        self.showInput();\n        self.setActiveItem(null);\n        self.refreshOptions(!!self.settings.openOnFocus);\n      }\n\n      self.refreshState();\n    },\n\n    /**\n     * Triggered on <input> blur.\n     *\n     * @param {object} e\n     * @param {Element} dest\n     */\n    onBlur: function (e, dest) {\n      var self = this;\n      if (!self.isFocused) return;\n      self.isFocused = false;\n\n      if (self.ignoreFocus) {\n        return;\n      } else if (!self.ignoreBlur && document.activeElement === self.$dropdown_content[0]) {\n        // necessary to prevent IE closing the dropdown when the scrollbar is clicked\n        self.ignoreBlur = true;\n        self.onFocus(e);\n        return;\n      }\n\n      var deactivate = function () {\n        self.close();\n        self.setTextboxValue('');\n        self.setActiveItem(null);\n        self.setActiveOption(null);\n        self.setCaret(self.items.length);\n        self.refreshState(); // IE11 bug: element still marked as active\n\n        dest && dest.focus && dest.focus();\n        self.isBlurring = false;\n        self.ignoreFocus = false;\n        self.trigger('blur');\n      };\n\n      self.isBlurring = true;\n      self.ignoreFocus = true;\n\n      if (self.settings.create && self.settings.createOnBlur) {\n        self.createItem(null, false, deactivate);\n      } else {\n        deactivate();\n      }\n    },\n\n    /**\n     * Triggered when the user rolls over\n     * an option in the autocomplete dropdown menu.\n     *\n     * @param {object} e\n     * @returns {boolean}\n     */\n    onOptionHover: function (e) {\n      if (this.ignoreHover) return;\n      this.setActiveOption(e.currentTarget, false);\n    },\n\n    /**\n     * Triggered when the user clicks on an option\n     * in the autocomplete dropdown menu.\n     *\n     * @param {object} e\n     * @returns {boolean}\n     */\n    onOptionSelect: function (e) {\n      var value,\n          $target,\n          $option,\n          self = this;\n\n      if (e.preventDefault) {\n        e.preventDefault();\n        e.stopPropagation();\n      }\n\n      $target = $(e.currentTarget);\n\n      if ($target.hasClass('create')) {\n        self.createItem(null, function () {\n          if (self.settings.closeAfterSelect) {\n            self.close();\n          }\n        });\n      } else {\n        value = $target.attr('data-value');\n\n        if (typeof value !== 'undefined') {\n          self.lastQuery = null;\n          self.setTextboxValue('');\n          self.addItem(value);\n\n          if (self.settings.closeAfterSelect) {\n            self.close();\n          } else if (!self.settings.hideSelected && e.type && /mouse/.test(e.type)) {\n            self.setActiveOption(self.getOption(value));\n          }\n        }\n      }\n    },\n\n    /**\n     * Triggered when the user clicks on an item\n     * that has been selected.\n     *\n     * @param {object} e\n     * @returns {boolean}\n     */\n    onItemSelect: function (e) {\n      var self = this;\n      if (self.isLocked) return;\n\n      if (self.settings.mode === 'multi') {\n        e.preventDefault();\n        self.setActiveItem(e.currentTarget, e);\n      }\n    },\n\n    /**\n     * Invokes the provided method that provides\n     * results to a callback---which are then added\n     * as options to the control.\n     *\n     * @param {function} fn\n     */\n    load: function (fn) {\n      var self = this;\n      var $wrapper = self.$wrapper.addClass(self.settings.loadingClass);\n      self.loading++;\n      fn.apply(self, [function (results) {\n        self.loading = Math.max(self.loading - 1, 0);\n\n        if (results && results.length) {\n          self.addOption(results);\n          self.refreshOptions(self.isFocused && !self.isInputHidden);\n        }\n\n        if (!self.loading) {\n          $wrapper.removeClass(self.settings.loadingClass);\n        }\n\n        self.trigger('load', results);\n      }]);\n    },\n\n    /**\n     * Sets the input field of the control to the specified value.\n     *\n     * @param {string} value\n     */\n    setTextboxValue: function (value) {\n      var $input = this.$control_input;\n      var changed = $input.val() !== value;\n\n      if (changed) {\n        $input.val(value).triggerHandler('update');\n        this.lastValue = value;\n      }\n    },\n\n    /**\n     * Returns the value of the control. If multiple items\n     * can be selected (e.g. <select multiple>), this returns\n     * an array. If only one item can be selected, this\n     * returns a string.\n     *\n     * @returns {mixed}\n     */\n    getValue: function () {\n      if (this.tagType === TAG_SELECT && this.$input.attr('multiple')) {\n        return this.items;\n      } else {\n        return this.items.join(this.settings.delimiter);\n      }\n    },\n\n    /**\n     * Resets the selected items to the given value.\n     *\n     * @param {mixed} value\n     */\n    setValue: function (value, silent) {\n      var events = silent ? [] : ['change'];\n      debounce_events(this, events, function () {\n        this.clear(silent);\n        this.addItems(value, silent);\n      });\n    },\n\n    /**\n     * Sets the selected item.\n     *\n     * @param {object} $item\n     * @param {object} e (optional)\n     */\n    setActiveItem: function ($item, e) {\n      var self = this;\n      var eventName;\n      var i, idx, begin, end, item, swap;\n      var $last;\n      if (self.settings.mode === 'single') return;\n      $item = $($item); // clear the active selection\n\n      if (!$item.length) {\n        $(self.$activeItems).removeClass('active');\n        self.$activeItems = [];\n\n        if (self.isFocused) {\n          self.showInput();\n        }\n\n        return;\n      } // modify selection\n\n\n      eventName = e && e.type.toLowerCase();\n\n      if (eventName === 'mousedown' && self.isShiftDown && self.$activeItems.length) {\n        $last = self.$control.children('.active:last');\n        begin = Array.prototype.indexOf.apply(self.$control[0].childNodes, [$last[0]]);\n        end = Array.prototype.indexOf.apply(self.$control[0].childNodes, [$item[0]]);\n\n        if (begin > end) {\n          swap = begin;\n          begin = end;\n          end = swap;\n        }\n\n        for (i = begin; i <= end; i++) {\n          item = self.$control[0].childNodes[i];\n\n          if (self.$activeItems.indexOf(item) === -1) {\n            $(item).addClass('active');\n            self.$activeItems.push(item);\n          }\n        }\n\n        e.preventDefault();\n      } else if (eventName === 'mousedown' && self.isCtrlDown || eventName === 'keydown' && this.isShiftDown) {\n        if ($item.hasClass('active')) {\n          idx = self.$activeItems.indexOf($item[0]);\n          self.$activeItems.splice(idx, 1);\n          $item.removeClass('active');\n        } else {\n          self.$activeItems.push($item.addClass('active')[0]);\n        }\n      } else {\n        $(self.$activeItems).removeClass('active');\n        self.$activeItems = [$item.addClass('active')[0]];\n      } // ensure control has focus\n\n\n      self.hideInput();\n\n      if (!this.isFocused) {\n        self.focus();\n      }\n    },\n\n    /**\n     * Sets the selected item in the dropdown menu\n     * of available options.\n     *\n     * @param {object} $object\n     * @param {boolean} scroll\n     * @param {boolean} animate\n     */\n    setActiveOption: function ($option, scroll, animate) {\n      var height_menu, height_item, y;\n      var scroll_top, scroll_bottom;\n      var self = this;\n      if (self.$activeOption) self.$activeOption.removeClass('active');\n      self.$activeOption = null;\n      $option = $($option);\n      if (!$option.length) return;\n      self.$activeOption = $option.addClass('active');\n\n      if (scroll || !isset(scroll)) {\n        height_menu = self.$dropdown_content.height();\n        height_item = self.$activeOption.outerHeight(true);\n        scroll = self.$dropdown_content.scrollTop() || 0;\n        y = self.$activeOption.offset().top - self.$dropdown_content.offset().top + scroll;\n        scroll_top = y;\n        scroll_bottom = y - height_menu + height_item;\n\n        if (y + height_item > height_menu + scroll) {\n          self.$dropdown_content.stop().animate({\n            scrollTop: scroll_bottom\n          }, animate ? self.settings.scrollDuration : 0);\n        } else if (y < scroll) {\n          self.$dropdown_content.stop().animate({\n            scrollTop: scroll_top\n          }, animate ? self.settings.scrollDuration : 0);\n        }\n      }\n    },\n\n    /**\n     * Selects all items (CTRL + A).\n     */\n    selectAll: function () {\n      var self = this;\n      if (self.settings.mode === 'single') return;\n      self.$activeItems = Array.prototype.slice.apply(self.$control.children(':not(input)').addClass('active'));\n\n      if (self.$activeItems.length) {\n        self.hideInput();\n        self.close();\n      }\n\n      self.focus();\n    },\n\n    /**\n     * Hides the input element out of view, while\n     * retaining its focus.\n     */\n    hideInput: function () {\n      var self = this;\n      self.setTextboxValue('');\n      self.$control_input.css({\n        opacity: 0,\n        position: 'absolute',\n        left: self.rtl ? 10000 : -10000\n      });\n      self.isInputHidden = true;\n    },\n\n    /**\n     * Restores input visibility.\n     */\n    showInput: function () {\n      this.$control_input.css({\n        opacity: 1,\n        position: 'relative',\n        left: 0\n      });\n      this.isInputHidden = false;\n    },\n\n    /**\n     * Gives the control focus.\n     */\n    focus: function () {\n      var self = this;\n      if (self.isDisabled) return;\n      self.ignoreFocus = true;\n      self.$control_input[0].focus();\n      window.setTimeout(function () {\n        self.ignoreFocus = false;\n        self.onFocus();\n      }, 0);\n    },\n\n    /**\n     * Forces the control out of focus.\n     *\n     * @param {Element} dest\n     */\n    blur: function (dest) {\n      this.$control_input[0].blur();\n      this.onBlur(null, dest);\n    },\n\n    /**\n     * Returns a function that scores an object\n     * to show how good of a match it is to the\n     * provided query.\n     *\n     * @param {string} query\n     * @param {object} options\n     * @return {function}\n     */\n    getScoreFunction: function (query) {\n      return this.sifter.getScoreFunction(query, this.getSearchOptions());\n    },\n\n    /**\n     * Returns search options for sifter (the system\n     * for scoring and sorting results).\n     *\n     * @see https://github.com/brianreavis/sifter.js\n     * @return {object}\n     */\n    getSearchOptions: function () {\n      var settings = this.settings;\n      var sort = settings.sortField;\n\n      if (typeof sort === 'string') {\n        sort = [{\n          field: sort\n        }];\n      }\n\n      return {\n        fields: settings.searchField,\n        conjunction: settings.searchConjunction,\n        sort: sort,\n        nesting: settings.nesting\n      };\n    },\n\n    /**\n     * Searches through available options and returns\n     * a sorted array of matches.\n     *\n     * Returns an object containing:\n     *\n     *   - query {string}\n     *   - tokens {array}\n     *   - total {int}\n     *   - items {array}\n     *\n     * @param {string} query\n     * @returns {object}\n     */\n    search: function (query) {\n      var i, value, score, result, calculateScore;\n      var self = this;\n      var settings = self.settings;\n      var options = this.getSearchOptions(); // validate user-provided result scoring function\n\n      if (settings.score) {\n        calculateScore = self.settings.score.apply(this, [query]);\n\n        if (typeof calculateScore !== 'function') {\n          throw new Error('Selectize \"score\" setting must be a function that returns a function');\n        }\n      } // perform search\n\n\n      if (query !== self.lastQuery) {\n        self.lastQuery = query;\n        result = self.sifter.search(query, $.extend(options, {\n          score: calculateScore\n        }));\n        self.currentResults = result;\n      } else {\n        result = $.extend(true, {}, self.currentResults);\n      } // filter out selected items\n\n\n      if (settings.hideSelected) {\n        for (i = result.items.length - 1; i >= 0; i--) {\n          if (self.items.indexOf(hash_key(result.items[i].id)) !== -1) {\n            result.items.splice(i, 1);\n          }\n        }\n      }\n\n      return result;\n    },\n\n    /**\n     * Refreshes the list of available options shown\n     * in the autocomplete dropdown menu.\n     *\n     * @param {boolean} triggerDropdown\n     */\n    refreshOptions: function (triggerDropdown) {\n      var i, j, k, n, groups, groups_order, option, option_html, optgroup, optgroups, html, html_children, has_create_option;\n      var $active, $active_before, $create;\n\n      if (typeof triggerDropdown === 'undefined') {\n        triggerDropdown = true;\n      }\n\n      var self = this;\n      var query = $.trim(self.$control_input.val());\n      var results = self.search(query);\n      var $dropdown_content = self.$dropdown_content;\n      var active_before = self.$activeOption && hash_key(self.$activeOption.attr('data-value')); // build markup\n\n      n = results.items.length;\n\n      if (typeof self.settings.maxOptions === 'number') {\n        n = Math.min(n, self.settings.maxOptions);\n      } // render and group available options individually\n\n\n      groups = {};\n      groups_order = [];\n\n      for (i = 0; i < n; i++) {\n        option = self.options[results.items[i].id];\n        option_html = self.render('option', option);\n        optgroup = option[self.settings.optgroupField] || '';\n        optgroups = $.isArray(optgroup) ? optgroup : [optgroup];\n\n        for (j = 0, k = optgroups && optgroups.length; j < k; j++) {\n          optgroup = optgroups[j];\n\n          if (!self.optgroups.hasOwnProperty(optgroup)) {\n            optgroup = '';\n          }\n\n          if (!groups.hasOwnProperty(optgroup)) {\n            groups[optgroup] = document.createDocumentFragment();\n            groups_order.push(optgroup);\n          }\n\n          groups[optgroup].appendChild(option_html);\n        }\n      } // sort optgroups\n\n\n      if (this.settings.lockOptgroupOrder) {\n        groups_order.sort(function (a, b) {\n          var a_order = self.optgroups[a].$order || 0;\n          var b_order = self.optgroups[b].$order || 0;\n          return a_order - b_order;\n        });\n      } // render optgroup headers & join groups\n\n\n      html = document.createDocumentFragment();\n\n      for (i = 0, n = groups_order.length; i < n; i++) {\n        optgroup = groups_order[i];\n\n        if (self.optgroups.hasOwnProperty(optgroup) && groups[optgroup].childNodes.length) {\n          // render the optgroup header and options within it,\n          // then pass it to the wrapper template\n          html_children = document.createDocumentFragment();\n          html_children.appendChild(self.render('optgroup_header', self.optgroups[optgroup]));\n          html_children.appendChild(groups[optgroup]);\n          html.appendChild(self.render('optgroup', $.extend({}, self.optgroups[optgroup], {\n            html: domToString(html_children),\n            dom: html_children\n          })));\n        } else {\n          html.appendChild(groups[optgroup]);\n        }\n      }\n\n      $dropdown_content.html(html); // highlight matching terms inline\n\n      if (self.settings.highlight) {\n        $dropdown_content.removeHighlight();\n\n        if (results.query.length && results.tokens.length) {\n          for (i = 0, n = results.tokens.length; i < n; i++) {\n            highlight($dropdown_content, results.tokens[i].regex);\n          }\n        }\n      } // add \"selected\" class to selected options\n\n\n      if (!self.settings.hideSelected) {\n        for (i = 0, n = self.items.length; i < n; i++) {\n          self.getOption(self.items[i]).addClass('selected');\n        }\n      } // add create option\n\n\n      has_create_option = self.canCreate(query);\n\n      if (has_create_option) {\n        $dropdown_content.prepend(self.render('option_create', {\n          input: query\n        }));\n        $create = $($dropdown_content[0].childNodes[0]);\n      } // activate\n\n\n      self.hasOptions = results.items.length > 0 || has_create_option;\n\n      if (self.hasOptions) {\n        if (results.items.length > 0) {\n          $active_before = active_before && self.getOption(active_before);\n\n          if ($active_before && $active_before.length) {\n            $active = $active_before;\n          } else if (self.settings.mode === 'single' && self.items.length) {\n            $active = self.getOption(self.items[0]);\n          }\n\n          if (!$active || !$active.length) {\n            if ($create && !self.settings.addPrecedence) {\n              $active = self.getAdjacentOption($create, 1);\n            } else {\n              $active = $dropdown_content.find('[data-selectable]:first');\n            }\n          }\n        } else {\n          $active = $create;\n        }\n\n        self.setActiveOption($active);\n\n        if (triggerDropdown && !self.isOpen) {\n          self.open();\n        }\n      } else {\n        self.setActiveOption(null);\n\n        if (triggerDropdown && self.isOpen) {\n          self.close();\n        }\n      }\n    },\n\n    /**\n     * Adds an available option. If it already exists,\n     * nothing will happen. Note: this does not refresh\n     * the options list dropdown (use `refreshOptions`\n     * for that).\n     *\n     * Usage:\n     *\n     *   this.addOption(data)\n     *\n     * @param {object|array} data\n     */\n    addOption: function (data) {\n      var i,\n          n,\n          value,\n          self = this;\n\n      if ($.isArray(data)) {\n        for (i = 0, n = data.length; i < n; i++) {\n          self.addOption(data[i]);\n        }\n\n        return;\n      }\n\n      if (value = self.registerOption(data)) {\n        self.userOptions[value] = true;\n        self.lastQuery = null;\n        self.trigger('option_add', value, data);\n      }\n    },\n\n    /**\n     * Registers an option to the pool of options.\n     *\n     * @param {object} data\n     * @return {boolean|string}\n     */\n    registerOption: function (data) {\n      var key = hash_key(data[this.settings.valueField]);\n      if (typeof key === 'undefined' || key === null || this.options.hasOwnProperty(key)) return false;\n      data.$order = data.$order || ++this.order;\n      this.options[key] = data;\n      return key;\n    },\n\n    /**\n     * Registers an option group to the pool of option groups.\n     *\n     * @param {object} data\n     * @return {boolean|string}\n     */\n    registerOptionGroup: function (data) {\n      var key = hash_key(data[this.settings.optgroupValueField]);\n      if (!key) return false;\n      data.$order = data.$order || ++this.order;\n      this.optgroups[key] = data;\n      return key;\n    },\n\n    /**\n     * Registers a new optgroup for options\n     * to be bucketed into.\n     *\n     * @param {string} id\n     * @param {object} data\n     */\n    addOptionGroup: function (id, data) {\n      data[this.settings.optgroupValueField] = id;\n\n      if (id = this.registerOptionGroup(data)) {\n        this.trigger('optgroup_add', id, data);\n      }\n    },\n\n    /**\n     * Removes an existing option group.\n     *\n     * @param {string} id\n     */\n    removeOptionGroup: function (id) {\n      if (this.optgroups.hasOwnProperty(id)) {\n        delete this.optgroups[id];\n        this.renderCache = {};\n        this.trigger('optgroup_remove', id);\n      }\n    },\n\n    /**\n     * Clears all existing option groups.\n     */\n    clearOptionGroups: function () {\n      this.optgroups = {};\n      this.renderCache = {};\n      this.trigger('optgroup_clear');\n    },\n\n    /**\n     * Updates an option available for selection. If\n     * it is visible in the selected items or options\n     * dropdown, it will be re-rendered automatically.\n     *\n     * @param {string} value\n     * @param {object} data\n     */\n    updateOption: function (value, data) {\n      var self = this;\n      var $item, $item_new;\n      var value_new, index_item, cache_items, cache_options, order_old;\n      value = hash_key(value);\n      value_new = hash_key(data[self.settings.valueField]); // sanity checks\n\n      if (value === null) return;\n      if (!self.options.hasOwnProperty(value)) return;\n      if (typeof value_new !== 'string') throw new Error('Value must be set in option data');\n      order_old = self.options[value].$order; // update references\n\n      if (value_new !== value) {\n        delete self.options[value];\n        index_item = self.items.indexOf(value);\n\n        if (index_item !== -1) {\n          self.items.splice(index_item, 1, value_new);\n        }\n      }\n\n      data.$order = data.$order || order_old;\n      self.options[value_new] = data; // invalidate render cache\n\n      cache_items = self.renderCache['item'];\n      cache_options = self.renderCache['option'];\n\n      if (cache_items) {\n        delete cache_items[value];\n        delete cache_items[value_new];\n      }\n\n      if (cache_options) {\n        delete cache_options[value];\n        delete cache_options[value_new];\n      } // update the item if it's selected\n\n\n      if (self.items.indexOf(value_new) !== -1) {\n        $item = self.getItem(value);\n        $item_new = $(self.render('item', data));\n        if ($item.hasClass('active')) $item_new.addClass('active');\n        $item.replaceWith($item_new);\n      } // invalidate last query because we might have updated the sortField\n\n\n      self.lastQuery = null; // update dropdown contents\n\n      if (self.isOpen) {\n        self.refreshOptions(false);\n      }\n    },\n\n    /**\n     * Removes a single option.\n     *\n     * @param {string} value\n     * @param {boolean} silent\n     */\n    removeOption: function (value, silent) {\n      var self = this;\n      value = hash_key(value);\n      var cache_items = self.renderCache['item'];\n      var cache_options = self.renderCache['option'];\n      if (cache_items) delete cache_items[value];\n      if (cache_options) delete cache_options[value];\n      delete self.userOptions[value];\n      delete self.options[value];\n      self.lastQuery = null;\n      self.trigger('option_remove', value);\n      self.removeItem(value, silent);\n    },\n\n    /**\n     * Clears all options.\n     */\n    clearOptions: function () {\n      var self = this;\n      self.loadedSearches = {};\n      self.userOptions = {};\n      self.renderCache = {};\n      var options = self.options;\n      $.each(self.options, function (key, value) {\n        if (self.items.indexOf(key) == -1) {\n          delete options[key];\n        }\n      });\n      self.options = self.sifter.items = options;\n      self.lastQuery = null;\n      self.trigger('option_clear');\n    },\n\n    /**\n     * Returns the jQuery element of the option\n     * matching the given value.\n     *\n     * @param {string} value\n     * @returns {object}\n     */\n    getOption: function (value) {\n      return this.getElementWithValue(value, this.$dropdown_content.find('[data-selectable]'));\n    },\n\n    /**\n     * Returns the jQuery element of the next or\n     * previous selectable option.\n     *\n     * @param {object} $option\n     * @param {int} direction  can be 1 for next or -1 for previous\n     * @return {object}\n     */\n    getAdjacentOption: function ($option, direction) {\n      var $options = this.$dropdown.find('[data-selectable]');\n      var index = $options.index($option) + direction;\n      return index >= 0 && index < $options.length ? $options.eq(index) : $();\n    },\n\n    /**\n     * Finds the first element with a \"data-value\" attribute\n     * that matches the given value.\n     *\n     * @param {mixed} value\n     * @param {object} $els\n     * @return {object}\n     */\n    getElementWithValue: function (value, $els) {\n      value = hash_key(value);\n\n      if (typeof value !== 'undefined' && value !== null) {\n        for (var i = 0, n = $els.length; i < n; i++) {\n          if ($els[i].getAttribute('data-value') === value) {\n            return $($els[i]);\n          }\n        }\n      }\n\n      return $();\n    },\n\n    /**\n     * Returns the jQuery element of the item\n     * matching the given value.\n     *\n     * @param {string} value\n     * @returns {object}\n     */\n    getItem: function (value) {\n      return this.getElementWithValue(value, this.$control.children());\n    },\n\n    /**\n     * \"Selects\" multiple items at once. Adds them to the list\n     * at the current caret position.\n     *\n     * @param {string} value\n     * @param {boolean} silent\n     */\n    addItems: function (values, silent) {\n      this.buffer = document.createDocumentFragment();\n      var childNodes = this.$control[0].childNodes;\n\n      for (var i = 0; i < childNodes.length; i++) {\n        this.buffer.appendChild(childNodes[i]);\n      }\n\n      var items = $.isArray(values) ? values : [values];\n\n      for (var i = 0, n = items.length; i < n; i++) {\n        this.isPending = i < n - 1;\n        this.addItem(items[i], silent);\n      }\n\n      var control = this.$control[0];\n      control.insertBefore(this.buffer, control.firstChild);\n      this.buffer = null;\n    },\n\n    /**\n     * \"Selects\" an item. Adds it to the list\n     * at the current caret position.\n     *\n     * @param {string} value\n     * @param {boolean} silent\n     */\n    addItem: function (value, silent) {\n      var events = silent ? [] : ['change'];\n      debounce_events(this, events, function () {\n        var $item, $option, $options;\n        var self = this;\n        var inputMode = self.settings.mode;\n        var i, active, value_next, wasFull;\n        value = hash_key(value);\n\n        if (self.items.indexOf(value) !== -1) {\n          if (inputMode === 'single') self.close();\n          return;\n        }\n\n        if (!self.options.hasOwnProperty(value)) return;\n        if (inputMode === 'single') self.clear(silent);\n        if (inputMode === 'multi' && self.isFull()) return;\n        $item = $(self.render('item', self.options[value]));\n        wasFull = self.isFull();\n        self.items.splice(self.caretPos, 0, value);\n        self.insertAtCaret($item);\n\n        if (!self.isPending || !wasFull && self.isFull()) {\n          self.refreshState();\n        }\n\n        if (self.isSetup) {\n          $options = self.$dropdown_content.find('[data-selectable]'); // update menu / remove the option (if this is not one item being added as part of series)\n\n          if (!self.isPending) {\n            $option = self.getOption(value);\n            value_next = self.getAdjacentOption($option, 1).attr('data-value');\n            self.refreshOptions(self.isFocused && inputMode !== 'single');\n\n            if (value_next) {\n              self.setActiveOption(self.getOption(value_next));\n            }\n          } // hide the menu if the maximum number of items have been selected or no options are left\n\n\n          if (!$options.length || self.isFull()) {\n            self.close();\n          } else if (!self.isPending) {\n            self.positionDropdown();\n          }\n\n          self.updatePlaceholder();\n          self.trigger('item_add', value, $item);\n\n          if (!self.isPending) {\n            self.updateOriginalInput({\n              silent: silent\n            });\n          }\n        }\n      });\n    },\n\n    /**\n     * Removes the selected item matching\n     * the provided value.\n     *\n     * @param {string} value\n     */\n    removeItem: function (value, silent) {\n      var self = this;\n      var $item, i, idx;\n      $item = value instanceof $ ? value : self.getItem(value);\n      value = hash_key($item.attr('data-value'));\n      i = self.items.indexOf(value);\n\n      if (i !== -1) {\n        $item.remove();\n\n        if ($item.hasClass('active')) {\n          idx = self.$activeItems.indexOf($item[0]);\n          self.$activeItems.splice(idx, 1);\n        }\n\n        self.items.splice(i, 1);\n        self.lastQuery = null;\n\n        if (!self.settings.persist && self.userOptions.hasOwnProperty(value)) {\n          self.removeOption(value, silent);\n        }\n\n        if (i < self.caretPos) {\n          self.setCaret(self.caretPos - 1);\n        }\n\n        self.refreshState();\n        self.updatePlaceholder();\n        self.updateOriginalInput({\n          silent: silent\n        });\n        self.positionDropdown();\n        self.trigger('item_remove', value, $item);\n      }\n    },\n\n    /**\n     * Invokes the `create` method provided in the\n     * selectize options that should provide the data\n     * for the new item, given the user input.\n     *\n     * Once this completes, it will be added\n     * to the item list.\n     *\n     * @param {string} value\n     * @param {boolean} [triggerDropdown]\n     * @param {function} [callback]\n     * @return {boolean}\n     */\n    createItem: function (input, triggerDropdown) {\n      var self = this;\n      var caret = self.caretPos;\n      input = input || $.trim(self.$control_input.val() || '');\n      var callback = arguments[arguments.length - 1];\n      if (typeof callback !== 'function') callback = function () {};\n\n      if (typeof triggerDropdown !== 'boolean') {\n        triggerDropdown = true;\n      }\n\n      if (!self.canCreate(input)) {\n        callback();\n        return false;\n      }\n\n      self.lock();\n      var setup = typeof self.settings.create === 'function' ? this.settings.create : function (input) {\n        var data = {};\n        data[self.settings.labelField] = input;\n        data[self.settings.valueField] = input;\n        return data;\n      };\n      var create = once(function (data) {\n        self.unlock();\n        if (!data || typeof data !== 'object') return callback();\n        var value = hash_key(data[self.settings.valueField]);\n        if (typeof value !== 'string') return callback();\n        self.setTextboxValue('');\n        self.addOption(data);\n        self.setCaret(caret);\n        self.addItem(value);\n        self.refreshOptions(triggerDropdown && self.settings.mode !== 'single');\n        callback(data);\n      });\n      var output = setup.apply(this, [input, create]);\n\n      if (typeof output !== 'undefined') {\n        create(output);\n      }\n\n      return true;\n    },\n\n    /**\n     * Re-renders the selected item lists.\n     */\n    refreshItems: function () {\n      this.lastQuery = null;\n\n      if (this.isSetup) {\n        this.addItem(this.items);\n      }\n\n      this.refreshState();\n      this.updateOriginalInput();\n    },\n\n    /**\n     * Updates all state-dependent attributes\n     * and CSS classes.\n     */\n    refreshState: function () {\n      this.refreshValidityState();\n      this.refreshClasses();\n    },\n\n    /**\n     * Update the `required` attribute of both input and control input.\n     *\n     * The `required` property needs to be activated on the control input\n     * for the error to be displayed at the right place. `required` also\n     * needs to be temporarily deactivated on the input since the input is\n     * hidden and can't show errors.\n     */\n    refreshValidityState: function () {\n      if (!this.isRequired) return false;\n      var invalid = !this.items.length;\n      this.isInvalid = invalid;\n      this.$control_input.prop('required', invalid);\n      this.$input.prop('required', !invalid);\n    },\n\n    /**\n     * Updates all state-dependent CSS classes.\n     */\n    refreshClasses: function () {\n      var self = this;\n      var isFull = self.isFull();\n      var isLocked = self.isLocked;\n      self.$wrapper.toggleClass('rtl', self.rtl);\n      self.$control.toggleClass('focus', self.isFocused).toggleClass('disabled', self.isDisabled).toggleClass('required', self.isRequired).toggleClass('invalid', self.isInvalid).toggleClass('locked', isLocked).toggleClass('full', isFull).toggleClass('not-full', !isFull).toggleClass('input-active', self.isFocused && !self.isInputHidden).toggleClass('dropdown-active', self.isOpen).toggleClass('has-options', !$.isEmptyObject(self.options)).toggleClass('has-items', self.items.length > 0);\n      self.$control_input.data('grow', !isFull && !isLocked);\n    },\n\n    /**\n     * Determines whether or not more items can be added\n     * to the control without exceeding the user-defined maximum.\n     *\n     * @returns {boolean}\n     */\n    isFull: function () {\n      return this.settings.maxItems !== null && this.items.length >= this.settings.maxItems;\n    },\n\n    /**\n     * Refreshes the original <select> or <input>\n     * element to reflect the current state.\n     */\n    updateOriginalInput: function (opts) {\n      var i,\n          n,\n          options,\n          label,\n          self = this;\n      opts = opts || {};\n\n      if (self.tagType === TAG_SELECT) {\n        options = [];\n\n        for (i = 0, n = self.items.length; i < n; i++) {\n          label = self.options[self.items[i]][self.settings.labelField] || '';\n          options.push('<option value=\"' + escape_html(self.items[i]) + '\" selected=\"selected\">' + escape_html(label) + '</option>');\n        }\n\n        if (!options.length && !this.$input.attr('multiple')) {\n          options.push('<option value=\"\" selected=\"selected\"></option>');\n        }\n\n        self.$input.html(options.join(''));\n      } else {\n        self.$input.val(self.getValue());\n        self.$input.attr('value', self.$input.val());\n      }\n\n      if (self.isSetup) {\n        if (!opts.silent) {\n          self.trigger('change', self.$input.val());\n        }\n      }\n    },\n\n    /**\n     * Shows/hide the input placeholder depending\n     * on if there items in the list already.\n     */\n    updatePlaceholder: function () {\n      if (!this.settings.placeholder) return;\n      var $input = this.$control_input;\n\n      if (this.items.length) {\n        $input.removeAttr('placeholder');\n      } else {\n        $input.attr('placeholder', this.settings.placeholder);\n      }\n\n      $input.triggerHandler('update', {\n        force: true\n      });\n    },\n\n    /**\n     * Shows the autocomplete dropdown containing\n     * the available options.\n     */\n    open: function () {\n      var self = this;\n      if (self.isLocked || self.isOpen || self.settings.mode === 'multi' && self.isFull()) return;\n      self.focus();\n      self.isOpen = true;\n      self.refreshState();\n      self.$dropdown.css({\n        visibility: 'hidden',\n        display: 'block'\n      });\n      self.positionDropdown();\n      self.$dropdown.css({\n        visibility: 'visible'\n      });\n      self.trigger('dropdown_open', self.$dropdown);\n    },\n\n    /**\n     * Closes the autocomplete dropdown menu.\n     */\n    close: function () {\n      var self = this;\n      var trigger = self.isOpen;\n\n      if (self.settings.mode === 'single' && self.items.length) {\n        self.hideInput(); // Do not trigger blur while inside a blur event,\n        // this fixes some weird tabbing behavior in FF and IE.\n        // See #1164\n\n        if (!self.isBlurring) {\n          self.$control_input.blur(); // close keyboard on iOS\n        }\n      }\n\n      self.isOpen = false;\n      self.$dropdown.hide();\n      self.setActiveOption(null);\n      self.refreshState();\n      if (trigger) self.trigger('dropdown_close', self.$dropdown);\n    },\n\n    /**\n     * Calculates and applies the appropriate\n     * position of the dropdown.\n     */\n    positionDropdown: function () {\n      var $control = this.$control;\n      var offset = this.settings.dropdownParent === 'body' ? $control.offset() : $control.position();\n      offset.top += $control.outerHeight(true);\n      this.$dropdown.css({\n        width: $control[0].getBoundingClientRect().width,\n        top: offset.top,\n        left: offset.left\n      });\n    },\n\n    /**\n     * Resets / clears all selected items\n     * from the control.\n     *\n     * @param {boolean} silent\n     */\n    clear: function (silent) {\n      var self = this;\n      if (!self.items.length) return;\n      self.$control.children(':not(input)').remove();\n      self.items = [];\n      self.lastQuery = null;\n      self.setCaret(0);\n      self.setActiveItem(null);\n      self.updatePlaceholder();\n      self.updateOriginalInput({\n        silent: silent\n      });\n      self.refreshState();\n      self.showInput();\n      self.trigger('clear');\n    },\n\n    /**\n     * A helper method for inserting an element\n     * at the current caret position.\n     *\n     * @param {object} $el\n     */\n    insertAtCaret: function ($el) {\n      var caret = Math.min(this.caretPos, this.items.length);\n      var el = $el[0];\n      var target = this.buffer || this.$control[0];\n\n      if (caret === 0) {\n        target.insertBefore(el, target.firstChild);\n      } else {\n        target.insertBefore(el, target.childNodes[caret]);\n      }\n\n      this.setCaret(caret + 1);\n    },\n\n    /**\n     * Removes the current selected item(s).\n     *\n     * @param {object} e (optional)\n     * @returns {boolean}\n     */\n    deleteSelection: function (e) {\n      var i, n, direction, selection, values, caret, option_select, $option_select, $tail;\n      var self = this;\n      direction = e && e.keyCode === KEY_BACKSPACE ? -1 : 1;\n      selection = getSelection(self.$control_input[0]);\n\n      if (self.$activeOption && !self.settings.hideSelected) {\n        option_select = self.getAdjacentOption(self.$activeOption, -1).attr('data-value');\n      } // determine items that will be removed\n\n\n      values = [];\n\n      if (self.$activeItems.length) {\n        $tail = self.$control.children('.active:' + (direction > 0 ? 'last' : 'first'));\n        caret = self.$control.children(':not(input)').index($tail);\n\n        if (direction > 0) {\n          caret++;\n        }\n\n        for (i = 0, n = self.$activeItems.length; i < n; i++) {\n          values.push($(self.$activeItems[i]).attr('data-value'));\n        }\n\n        if (e) {\n          e.preventDefault();\n          e.stopPropagation();\n        }\n      } else if ((self.isFocused || self.settings.mode === 'single') && self.items.length) {\n        if (direction < 0 && selection.start === 0 && selection.length === 0) {\n          values.push(self.items[self.caretPos - 1]);\n        } else if (direction > 0 && selection.start === self.$control_input.val().length) {\n          values.push(self.items[self.caretPos]);\n        }\n      } // allow the callback to abort\n\n\n      if (!values.length || typeof self.settings.onDelete === 'function' && self.settings.onDelete.apply(self, [values]) === false) {\n        return false;\n      } // perform removal\n\n\n      if (typeof caret !== 'undefined') {\n        self.setCaret(caret);\n      }\n\n      while (values.length) {\n        self.removeItem(values.pop());\n      }\n\n      self.showInput();\n      self.positionDropdown();\n      self.refreshOptions(true); // select previous option\n\n      if (option_select) {\n        $option_select = self.getOption(option_select);\n\n        if ($option_select.length) {\n          self.setActiveOption($option_select);\n        }\n      }\n\n      return true;\n    },\n\n    /**\n     * Selects the previous / next item (depending\n     * on the `direction` argument).\n     *\n     * > 0 - right\n     * < 0 - left\n     *\n     * @param {int} direction\n     * @param {object} e (optional)\n     */\n    advanceSelection: function (direction, e) {\n      var tail, selection, idx, valueLength, cursorAtEdge, $tail;\n      var self = this;\n      if (direction === 0) return;\n      if (self.rtl) direction *= -1;\n      tail = direction > 0 ? 'last' : 'first';\n      selection = getSelection(self.$control_input[0]);\n\n      if (self.isFocused && !self.isInputHidden) {\n        valueLength = self.$control_input.val().length;\n        cursorAtEdge = direction < 0 ? selection.start === 0 && selection.length === 0 : selection.start === valueLength;\n\n        if (cursorAtEdge && !valueLength) {\n          self.advanceCaret(direction, e);\n        }\n      } else {\n        $tail = self.$control.children('.active:' + tail);\n\n        if ($tail.length) {\n          idx = self.$control.children(':not(input)').index($tail);\n          self.setActiveItem(null);\n          self.setCaret(direction > 0 ? idx + 1 : idx);\n        }\n      }\n    },\n\n    /**\n     * Moves the caret left / right.\n     *\n     * @param {int} direction\n     * @param {object} e (optional)\n     */\n    advanceCaret: function (direction, e) {\n      var self = this,\n          fn,\n          $adj;\n      if (direction === 0) return;\n      fn = direction > 0 ? 'next' : 'prev';\n\n      if (self.isShiftDown) {\n        $adj = self.$control_input[fn]();\n\n        if ($adj.length) {\n          self.hideInput();\n          self.setActiveItem($adj);\n          e && e.preventDefault();\n        }\n      } else {\n        self.setCaret(self.caretPos + direction);\n      }\n    },\n\n    /**\n     * Moves the caret to the specified index.\n     *\n     * @param {int} i\n     */\n    setCaret: function (i) {\n      var self = this;\n\n      if (self.settings.mode === 'single') {\n        i = self.items.length;\n      } else {\n        i = Math.max(0, Math.min(self.items.length, i));\n      }\n\n      if (!self.isPending) {\n        // the input must be moved by leaving it in place and moving the\n        // siblings, due to the fact that focus cannot be restored once lost\n        // on mobile webkit devices\n        var j, n, fn, $children, $child;\n        $children = self.$control.children(':not(input)');\n\n        for (j = 0, n = $children.length; j < n; j++) {\n          $child = $($children[j]).detach();\n\n          if (j < i) {\n            self.$control_input.before($child);\n          } else {\n            self.$control.append($child);\n          }\n        }\n      }\n\n      self.caretPos = i;\n    },\n\n    /**\n     * Disables user input on the control. Used while\n     * items are being asynchronously created.\n     */\n    lock: function () {\n      this.close();\n      this.isLocked = true;\n      this.refreshState();\n    },\n\n    /**\n     * Re-enables user input on the control.\n     */\n    unlock: function () {\n      this.isLocked = false;\n      this.refreshState();\n    },\n\n    /**\n     * Disables user input on the control completely.\n     * While disabled, it cannot receive focus.\n     */\n    disable: function () {\n      var self = this;\n      self.$input.prop('disabled', true);\n      self.$control_input.prop('disabled', true).prop('tabindex', -1);\n      self.isDisabled = true;\n      self.lock();\n    },\n\n    /**\n     * Enables the control so that it can respond\n     * to focus and user input.\n     */\n    enable: function () {\n      var self = this;\n      self.$input.prop('disabled', false);\n      self.$control_input.prop('disabled', false).prop('tabindex', self.tabIndex);\n      self.isDisabled = false;\n      self.unlock();\n    },\n\n    /**\n     * Completely destroys the control and\n     * unbinds all event listeners so that it can\n     * be garbage collected.\n     */\n    destroy: function () {\n      var self = this;\n      var eventNS = self.eventNS;\n      var revertSettings = self.revertSettings;\n      self.trigger('destroy');\n      self.off();\n      self.$wrapper.remove();\n      self.$dropdown.remove();\n      self.$input.html('').append(revertSettings.$children).removeAttr('tabindex').removeClass('selectized').attr({\n        tabindex: revertSettings.tabindex\n      }).show();\n      self.$control_input.removeData('grow');\n      self.$input.removeData('selectize');\n\n      if (--Selectize.count == 0 && Selectize.$testInput) {\n        Selectize.$testInput.remove();\n        Selectize.$testInput = undefined;\n      }\n\n      $(window).off(eventNS);\n      $(document).off(eventNS);\n      $(document.body).off(eventNS);\n      delete self.$input[0].selectize;\n    },\n\n    /**\n     * A helper method for rendering \"item\" and\n     * \"option\" templates, given the data.\n     *\n     * @param {string} templateName\n     * @param {object} data\n     * @returns {string}\n     */\n    render: function (templateName, data) {\n      var value, id, label;\n      var html = '';\n      var cache = false;\n      var self = this;\n      var regex_tag = /^[\\t \\r\\n]*<([a-z][a-z0-9\\-_]*(?:\\:[a-z][a-z0-9\\-_]*)?)/i;\n\n      if (templateName === 'option' || templateName === 'item') {\n        value = hash_key(data[self.settings.valueField]);\n        cache = !!value;\n      } // pull markup from cache if it exists\n\n\n      if (cache) {\n        if (!isset(self.renderCache[templateName])) {\n          self.renderCache[templateName] = {};\n        }\n\n        if (self.renderCache[templateName].hasOwnProperty(value)) {\n          return self.renderCache[templateName][value];\n        }\n      } // render markup\n\n\n      html = $(self.settings.render[templateName].apply(this, [data, escape_html])); // add mandatory attributes\n\n      if (templateName === 'option' || templateName === 'option_create') {\n        if (!data[self.settings.disabledField]) {\n          html.attr('data-selectable', '');\n        }\n      } else if (templateName === 'optgroup') {\n        id = data[self.settings.optgroupValueField] || '';\n        html.attr('data-group', id);\n\n        if (data[self.settings.disabledField]) {\n          html.attr('data-disabled', '');\n        }\n      }\n\n      if (templateName === 'option' || templateName === 'item') {\n        html.attr('data-value', value || '');\n      } // update cache\n\n\n      if (cache) {\n        self.renderCache[templateName][value] = html[0];\n      }\n\n      return html[0];\n    },\n\n    /**\n     * Clears the render cache for a template. If\n     * no template is given, clears all render\n     * caches.\n     *\n     * @param {string} templateName\n     */\n    clearCache: function (templateName) {\n      var self = this;\n\n      if (typeof templateName === 'undefined') {\n        self.renderCache = {};\n      } else {\n        delete self.renderCache[templateName];\n      }\n    },\n\n    /**\n     * Determines whether or not to display the\n     * create item prompt, given a user input.\n     *\n     * @param {string} input\n     * @return {boolean}\n     */\n    canCreate: function (input) {\n      var self = this;\n      if (!self.settings.create) return false;\n      var filter = self.settings.createFilter;\n      return input.length && (typeof filter !== 'function' || filter.apply(self, [input])) && (typeof filter !== 'string' || new RegExp(filter).test(input)) && (!(filter instanceof RegExp) || filter.test(input));\n    }\n  });\n  Selectize.count = 0;\n  Selectize.defaults = {\n    options: [],\n    optgroups: [],\n    plugins: [],\n    delimiter: ',',\n    splitOn: null,\n    // regexp or string for splitting up values from a paste command\n    persist: true,\n    diacritics: true,\n    create: false,\n    createOnBlur: false,\n    createFilter: null,\n    highlight: true,\n    openOnFocus: true,\n    maxOptions: 1000,\n    maxItems: null,\n    hideSelected: null,\n    addPrecedence: false,\n    selectOnTab: false,\n    preload: false,\n    allowEmptyOption: false,\n    closeAfterSelect: false,\n    scrollDuration: 60,\n    loadThrottle: 300,\n    loadingClass: 'loading',\n    dataAttr: 'data-data',\n    optgroupField: 'optgroup',\n    valueField: 'value',\n    labelField: 'text',\n    disabledField: 'disabled',\n    optgroupLabelField: 'label',\n    optgroupValueField: 'value',\n    lockOptgroupOrder: false,\n    sortField: '$order',\n    searchField: ['text'],\n    searchConjunction: 'and',\n    mode: null,\n    wrapperClass: 'selectize-control',\n    inputClass: 'selectize-input',\n    dropdownClass: 'selectize-dropdown',\n    dropdownContentClass: 'selectize-dropdown-content',\n    dropdownParent: null,\n    copyClassesToDropdown: true,\n\n    /*\n    load                 : null, // function(query, callback) { ... }\n    score                : null, // function(search) { ... }\n    onInitialize         : null, // function() { ... }\n    onChange             : null, // function(value) { ... }\n    onItemAdd            : null, // function(value, $item) { ... }\n    onItemRemove         : null, // function(value) { ... }\n    onClear              : null, // function() { ... }\n    onOptionAdd          : null, // function(value, data) { ... }\n    onOptionRemove       : null, // function(value) { ... }\n    onOptionClear        : null, // function() { ... }\n    onOptionGroupAdd     : null, // function(id, data) { ... }\n    onOptionGroupRemove  : null, // function(id) { ... }\n    onOptionGroupClear   : null, // function() { ... }\n    onDropdownOpen       : null, // function($dropdown) { ... }\n    onDropdownClose      : null, // function($dropdown) { ... }\n    onType               : null, // function(str) { ... }\n    onDelete             : null, // function(values) { ... }\n    */\n    render: {\n      /*\n      item: null,\n      optgroup: null,\n      optgroup_header: null,\n      option: null,\n      option_create: null\n      */\n    }\n  };\n\n  $.fn.selectize = function (settings_user) {\n    var defaults = $.fn.selectize.defaults;\n    var settings = $.extend({}, defaults, settings_user);\n    var attr_data = settings.dataAttr;\n    var field_label = settings.labelField;\n    var field_value = settings.valueField;\n    var field_disabled = settings.disabledField;\n    var field_optgroup = settings.optgroupField;\n    var field_optgroup_label = settings.optgroupLabelField;\n    var field_optgroup_value = settings.optgroupValueField;\n    /**\n     * Initializes selectize from a <input type=\"text\"> element.\n     *\n     * @param {object} $input\n     * @param {object} settings_element\n     */\n\n    var init_textbox = function ($input, settings_element) {\n      var i, n, values, option;\n      var data_raw = $input.attr(attr_data);\n\n      if (!data_raw) {\n        var value = $.trim($input.val() || '');\n        if (!settings.allowEmptyOption && !value.length) return;\n        values = value.split(settings.delimiter);\n\n        for (i = 0, n = values.length; i < n; i++) {\n          option = {};\n          option[field_label] = values[i];\n          option[field_value] = values[i];\n          settings_element.options.push(option);\n        }\n\n        settings_element.items = values;\n      } else {\n        settings_element.options = JSON.parse(data_raw);\n\n        for (i = 0, n = settings_element.options.length; i < n; i++) {\n          settings_element.items.push(settings_element.options[i][field_value]);\n        }\n      }\n    };\n    /**\n     * Initializes selectize from a <select> element.\n     *\n     * @param {object} $input\n     * @param {object} settings_element\n     */\n\n\n    var init_select = function ($input, settings_element) {\n      var i,\n          n,\n          tagName,\n          $children,\n          order = 0;\n      var options = settings_element.options;\n      var optionsMap = {};\n\n      var readData = function ($el) {\n        var data = attr_data && $el.attr(attr_data);\n\n        if (typeof data === 'string' && data.length) {\n          return JSON.parse(data);\n        }\n\n        return null;\n      };\n\n      var addOption = function ($option, group) {\n        $option = $($option);\n        var value = hash_key($option.val());\n        if (!value && !settings.allowEmptyOption) return; // if the option already exists, it's probably been\n        // duplicated in another optgroup. in this case, push\n        // the current group to the \"optgroup\" property on the\n        // existing option so that it's rendered in both places.\n\n        if (optionsMap.hasOwnProperty(value)) {\n          if (group) {\n            var arr = optionsMap[value][field_optgroup];\n\n            if (!arr) {\n              optionsMap[value][field_optgroup] = group;\n            } else if (!$.isArray(arr)) {\n              optionsMap[value][field_optgroup] = [arr, group];\n            } else {\n              arr.push(group);\n            }\n          }\n\n          return;\n        }\n\n        var option = readData($option) || {};\n        option[field_label] = option[field_label] || $option.text();\n        option[field_value] = option[field_value] || value;\n        option[field_disabled] = option[field_disabled] || $option.prop('disabled');\n        option[field_optgroup] = option[field_optgroup] || group;\n        optionsMap[value] = option;\n        options.push(option);\n\n        if ($option.is(':selected')) {\n          settings_element.items.push(value);\n        }\n      };\n\n      var addGroup = function ($optgroup) {\n        var i, n, id, optgroup, $options;\n        $optgroup = $($optgroup);\n        id = $optgroup.attr('label');\n\n        if (id) {\n          optgroup = readData($optgroup) || {};\n          optgroup[field_optgroup_label] = id;\n          optgroup[field_optgroup_value] = id;\n          optgroup[field_disabled] = $optgroup.prop('disabled');\n          settings_element.optgroups.push(optgroup);\n        }\n\n        $options = $('option', $optgroup);\n\n        for (i = 0, n = $options.length; i < n; i++) {\n          addOption($options[i], id);\n        }\n      };\n\n      settings_element.maxItems = $input.attr('multiple') ? null : 1;\n      $children = $input.children();\n\n      for (i = 0, n = $children.length; i < n; i++) {\n        tagName = $children[i].tagName.toLowerCase();\n\n        if (tagName === 'optgroup') {\n          addGroup($children[i]);\n        } else if (tagName === 'option') {\n          addOption($children[i]);\n        }\n      }\n    };\n\n    return this.each(function () {\n      if (this.selectize) return;\n      var instance;\n      var $input = $(this);\n      var tag_name = this.tagName.toLowerCase();\n      var placeholder = $input.attr('placeholder') || $input.attr('data-placeholder');\n\n      if (!placeholder && !settings.allowEmptyOption) {\n        placeholder = $input.children('option[value=\"\"]').text();\n      }\n\n      var settings_element = {\n        'placeholder': placeholder,\n        'options': [],\n        'optgroups': [],\n        'items': []\n      };\n\n      if (tag_name === 'select') {\n        init_select($input, settings_element);\n      } else {\n        init_textbox($input, settings_element);\n      }\n\n      instance = new Selectize($input, $.extend(true, {}, defaults, settings_element, settings_user));\n    });\n  };\n\n  $.fn.selectize.defaults = Selectize.defaults;\n  $.fn.selectize.support = {\n    validity: SUPPORTS_VALIDITY_API\n  };\n  Selectize.define('drag_drop', function (options) {\n    if (!$.fn.sortable) throw new Error('The \"drag_drop\" plugin requires jQuery UI \"sortable\".');\n    if (this.settings.mode !== 'multi') return;\n    var self = this;\n\n    self.lock = function () {\n      var original = self.lock;\n      return function () {\n        var sortable = self.$control.data('sortable');\n        if (sortable) sortable.disable();\n        return original.apply(self, arguments);\n      };\n    }();\n\n    self.unlock = function () {\n      var original = self.unlock;\n      return function () {\n        var sortable = self.$control.data('sortable');\n        if (sortable) sortable.enable();\n        return original.apply(self, arguments);\n      };\n    }();\n\n    self.setup = function () {\n      var original = self.setup;\n      return function () {\n        original.apply(this, arguments);\n        var $control = self.$control.sortable({\n          items: '[data-value]',\n          forcePlaceholderSize: true,\n          disabled: self.isLocked,\n          start: function (e, ui) {\n            ui.placeholder.css('width', ui.helper.css('width'));\n            $control.css({\n              overflow: 'visible'\n            });\n          },\n          stop: function () {\n            $control.css({\n              overflow: 'hidden'\n            });\n            var active = self.$activeItems ? self.$activeItems.slice() : null;\n            var values = [];\n            $control.children('[data-value]').each(function () {\n              values.push($(this).attr('data-value'));\n            });\n            self.setValue(values);\n            self.setActiveItem(active);\n          }\n        });\n      };\n    }();\n  });\n  Selectize.define('dropdown_header', function (options) {\n    var self = this;\n    options = $.extend({\n      title: 'Untitled',\n      headerClass: 'selectize-dropdown-header',\n      titleRowClass: 'selectize-dropdown-header-title',\n      labelClass: 'selectize-dropdown-header-label',\n      closeClass: 'selectize-dropdown-header-close',\n      html: function (data) {\n        return '<div class=\"' + data.headerClass + '\">' + '<div class=\"' + data.titleRowClass + '\">' + '<span class=\"' + data.labelClass + '\">' + data.title + '</span>' + '<a href=\"javascript:void(0)\" class=\"' + data.closeClass + '\">&times;</a>' + '</div>' + '</div>';\n      }\n    }, options);\n\n    self.setup = function () {\n      var original = self.setup;\n      return function () {\n        original.apply(self, arguments);\n        self.$dropdown_header = $(options.html(options));\n        self.$dropdown.prepend(self.$dropdown_header);\n      };\n    }();\n  });\n  Selectize.define('optgroup_columns', function (options) {\n    var self = this;\n    options = $.extend({\n      equalizeWidth: true,\n      equalizeHeight: true\n    }, options);\n\n    this.getAdjacentOption = function ($option, direction) {\n      var $options = $option.closest('[data-group]').find('[data-selectable]');\n      var index = $options.index($option) + direction;\n      return index >= 0 && index < $options.length ? $options.eq(index) : $();\n    };\n\n    this.onKeyDown = function () {\n      var original = self.onKeyDown;\n      return function (e) {\n        var index, $option, $options, $optgroup;\n\n        if (this.isOpen && (e.keyCode === KEY_LEFT || e.keyCode === KEY_RIGHT)) {\n          self.ignoreHover = true;\n          $optgroup = this.$activeOption.closest('[data-group]');\n          index = $optgroup.find('[data-selectable]').index(this.$activeOption);\n\n          if (e.keyCode === KEY_LEFT) {\n            $optgroup = $optgroup.prev('[data-group]');\n          } else {\n            $optgroup = $optgroup.next('[data-group]');\n          }\n\n          $options = $optgroup.find('[data-selectable]');\n          $option = $options.eq(Math.min($options.length - 1, index));\n\n          if ($option.length) {\n            this.setActiveOption($option);\n          }\n\n          return;\n        }\n\n        return original.apply(this, arguments);\n      };\n    }();\n\n    var getScrollbarWidth = function () {\n      var div;\n      var width = getScrollbarWidth.width;\n      var doc = document;\n\n      if (typeof width === 'undefined') {\n        div = doc.createElement('div');\n        div.innerHTML = '<div style=\"width:50px;height:50px;position:absolute;left:-50px;top:-50px;overflow:auto;\"><div style=\"width:1px;height:100px;\"></div></div>';\n        div = div.firstChild;\n        doc.body.appendChild(div);\n        width = getScrollbarWidth.width = div.offsetWidth - div.clientWidth;\n        doc.body.removeChild(div);\n      }\n\n      return width;\n    };\n\n    var equalizeSizes = function () {\n      var i, n, height_max, width, width_last, width_parent, $optgroups;\n      $optgroups = $('[data-group]', self.$dropdown_content);\n      n = $optgroups.length;\n      if (!n || !self.$dropdown_content.width()) return;\n\n      if (options.equalizeHeight) {\n        height_max = 0;\n\n        for (i = 0; i < n; i++) {\n          height_max = Math.max(height_max, $optgroups.eq(i).height());\n        }\n\n        $optgroups.css({\n          height: height_max\n        });\n      }\n\n      if (options.equalizeWidth) {\n        width_parent = self.$dropdown_content.innerWidth() - getScrollbarWidth();\n        width = Math.round(width_parent / n);\n        $optgroups.css({\n          width: width\n        });\n\n        if (n > 1) {\n          width_last = width_parent - width * (n - 1);\n          $optgroups.eq(n - 1).css({\n            width: width_last\n          });\n        }\n      }\n    };\n\n    if (options.equalizeHeight || options.equalizeWidth) {\n      hook.after(this, 'positionDropdown', equalizeSizes);\n      hook.after(this, 'refreshOptions', equalizeSizes);\n    }\n  });\n  Selectize.define('remove_button', function (options) {\n    options = $.extend({\n      label: '&times;',\n      title: 'Remove',\n      className: 'remove',\n      append: true\n    }, options);\n\n    var singleClose = function (thisRef, options) {\n      options.className = 'remove-single';\n      var self = thisRef;\n      var html = '<a href=\"javascript:void(0)\" class=\"' + options.className + '\" tabindex=\"-1\" title=\"' + escape_html(options.title) + '\">' + options.label + '</a>';\n      /**\n       * Appends an element as a child (with raw HTML).\n       *\n       * @param {string} html_container\n       * @param {string} html_element\n       * @return {string}\n       */\n\n      var append = function (html_container, html_element) {\n        return $('<span>').append(html_container).append(html_element);\n      };\n\n      thisRef.setup = function () {\n        var original = self.setup;\n        return function () {\n          // override the item rendering method to add the button to each\n          if (options.append) {\n            var id = $(self.$input.context).attr('id');\n            var selectizer = $('#' + id);\n            var render_item = self.settings.render.item;\n\n            self.settings.render.item = function (data) {\n              return append(render_item.apply(thisRef, arguments), html);\n            };\n          }\n\n          original.apply(thisRef, arguments); // add event listener\n\n          thisRef.$control.on('click', '.' + options.className, function (e) {\n            e.preventDefault();\n            if (self.isLocked) return;\n            self.clear();\n          });\n        };\n      }();\n    };\n\n    var multiClose = function (thisRef, options) {\n      var self = thisRef;\n      var html = '<a href=\"javascript:void(0)\" class=\"' + options.className + '\" tabindex=\"-1\" title=\"' + escape_html(options.title) + '\">' + options.label + '</a>';\n      /**\n       * Appends an element as a child (with raw HTML).\n       *\n       * @param {string} html_container\n       * @param {string} html_element\n       * @return {string}\n       */\n\n      var append = function (html_container, html_element) {\n        var pos = html_container.search(/(<\\/[^>]+>\\s*)$/);\n        return html_container.substring(0, pos) + html_element + html_container.substring(pos);\n      };\n\n      thisRef.setup = function () {\n        var original = self.setup;\n        return function () {\n          // override the item rendering method to add the button to each\n          if (options.append) {\n            var render_item = self.settings.render.item;\n\n            self.settings.render.item = function (data) {\n              return append(render_item.apply(thisRef, arguments), html);\n            };\n          }\n\n          original.apply(thisRef, arguments); // add event listener\n\n          thisRef.$control.on('click', '.' + options.className, function (e) {\n            e.preventDefault();\n            if (self.isLocked) return;\n            var $item = $(e.currentTarget).parent();\n            self.setActiveItem($item);\n\n            if (self.deleteSelection()) {\n              self.setCaret(self.items.length);\n            }\n          });\n        };\n      }();\n    };\n\n    if (this.settings.mode === 'single') {\n      singleClose(this, options);\n      return;\n    } else {\n      multiClose(this, options);\n    }\n  });\n  Selectize.define('restore_on_backspace', function (options) {\n    var self = this;\n\n    options.text = options.text || function (option) {\n      return option[this.settings.labelField];\n    };\n\n    this.onKeyDown = function () {\n      var original = self.onKeyDown;\n      return function (e) {\n        var index, option;\n\n        if (e.keyCode === KEY_BACKSPACE && this.$control_input.val() === '' && !this.$activeItems.length) {\n          index = this.caretPos - 1;\n\n          if (index >= 0 && index < this.items.length) {\n            option = this.options[this.items[index]];\n\n            if (this.deleteSelection(e)) {\n              this.setTextboxValue(options.text.apply(this, [option]));\n              this.refreshOptions(true);\n            }\n\n            e.preventDefault();\n            return;\n          }\n        }\n\n        return original.apply(this, arguments);\n      };\n    }();\n  });\n  return Selectize;\n});","map":null,"metadata":{},"sourceType":"script"}