{"ast":null,"code":"/*! tooltipster v4.2.6 */\n!function (a, b) {\n  \"function\" == typeof define && define.amd ? define([\"jquery\"], function (a) {\n    return b(a);\n  }) : \"object\" == typeof exports ? module.exports = b(require(\"jquery\")) : b(jQuery);\n}(this, function (a) {\n  function b(a) {\n    this.$container, this.constraints = null, this.__$tooltip, this.__init(a);\n  }\n\n  function c(b, c) {\n    var d = !0;\n    return a.each(b, function (a, e) {\n      return void 0 === c[a] || b[a] !== c[a] ? (d = !1, !1) : void 0;\n    }), d;\n  }\n\n  function d(b) {\n    var c = b.attr(\"id\"),\n        d = c ? h.window.document.getElementById(c) : null;\n    return d ? d === b[0] : a.contains(h.window.document.body, b[0]);\n  }\n\n  function e() {\n    if (!g) return !1;\n    var a = g.document.body || g.document.documentElement,\n        b = a.style,\n        c = \"transition\",\n        d = [\"Moz\", \"Webkit\", \"Khtml\", \"O\", \"ms\"];\n    if (\"string\" == typeof b[c]) return !0;\n    c = c.charAt(0).toUpperCase() + c.substr(1);\n\n    for (var e = 0; e < d.length; e++) if (\"string\" == typeof b[d[e] + c]) return !0;\n\n    return !1;\n  }\n\n  var f = {\n    animation: \"fade\",\n    animationDuration: 350,\n    content: null,\n    contentAsHTML: !1,\n    contentCloning: !1,\n    debug: !0,\n    delay: 300,\n    delayTouch: [300, 500],\n    functionInit: null,\n    functionBefore: null,\n    functionReady: null,\n    functionAfter: null,\n    functionFormat: null,\n    IEmin: 6,\n    interactive: !1,\n    multiple: !1,\n    parent: null,\n    plugins: [\"sideTip\"],\n    repositionOnScroll: !1,\n    restoration: \"none\",\n    selfDestruction: !0,\n    theme: [],\n    timer: 0,\n    trackerInterval: 500,\n    trackOrigin: !1,\n    trackTooltip: !1,\n    trigger: \"hover\",\n    triggerClose: {\n      click: !1,\n      mouseleave: !1,\n      originClick: !1,\n      scroll: !1,\n      tap: !1,\n      touchleave: !1\n    },\n    triggerOpen: {\n      click: !1,\n      mouseenter: !1,\n      tap: !1,\n      touchstart: !1\n    },\n    updateAnimation: \"rotate\",\n    zIndex: 9999999\n  },\n      g = \"undefined\" != typeof window ? window : null,\n      h = {\n    hasTouchCapability: !(!g || !(\"ontouchstart\" in g || g.DocumentTouch && g.document instanceof g.DocumentTouch || g.navigator.maxTouchPoints)),\n    hasTransitions: e(),\n    IE: !1,\n    semVer: \"4.2.6\",\n    window: g\n  },\n      i = function () {\n    this.__$emitterPrivate = a({}), this.__$emitterPublic = a({}), this.__instancesLatestArr = [], this.__plugins = {}, this._env = h;\n  };\n\n  i.prototype = {\n    __bridge: function (b, c, d) {\n      if (!c[d]) {\n        var e = function () {};\n\n        e.prototype = b;\n        var g = new e();\n        g.__init && g.__init(c), a.each(b, function (a, b) {\n          0 != a.indexOf(\"__\") && (c[a] ? f.debug && console.log(\"The \" + a + \" method of the \" + d + \" plugin conflicts with another plugin or native methods\") : (c[a] = function () {\n            return g[a].apply(g, Array.prototype.slice.apply(arguments));\n          }, c[a].bridged = g));\n        }), c[d] = g;\n      }\n\n      return this;\n    },\n    __setWindow: function (a) {\n      return h.window = a, this;\n    },\n    _getRuler: function (a) {\n      return new b(a);\n    },\n    _off: function () {\n      return this.__$emitterPrivate.off.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments)), this;\n    },\n    _on: function () {\n      return this.__$emitterPrivate.on.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments)), this;\n    },\n    _one: function () {\n      return this.__$emitterPrivate.one.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments)), this;\n    },\n    _plugin: function (b) {\n      var c = this;\n\n      if (\"string\" == typeof b) {\n        var d = b,\n            e = null;\n        return d.indexOf(\".\") > 0 ? e = c.__plugins[d] : a.each(c.__plugins, function (a, b) {\n          return b.name.substring(b.name.length - d.length - 1) == \".\" + d ? (e = b, !1) : void 0;\n        }), e;\n      }\n\n      if (b.name.indexOf(\".\") < 0) throw new Error(\"Plugins must be namespaced\");\n      return c.__plugins[b.name] = b, b.core && c.__bridge(b.core, c, b.name), this;\n    },\n    _trigger: function () {\n      var a = Array.prototype.slice.apply(arguments);\n      return \"string\" == typeof a[0] && (a[0] = {\n        type: a[0]\n      }), this.__$emitterPrivate.trigger.apply(this.__$emitterPrivate, a), this.__$emitterPublic.trigger.apply(this.__$emitterPublic, a), this;\n    },\n    instances: function (b) {\n      var c = [],\n          d = b || \".tooltipstered\";\n      return a(d).each(function () {\n        var b = a(this),\n            d = b.data(\"tooltipster-ns\");\n        d && a.each(d, function (a, d) {\n          c.push(b.data(d));\n        });\n      }), c;\n    },\n    instancesLatest: function () {\n      return this.__instancesLatestArr;\n    },\n    off: function () {\n      return this.__$emitterPublic.off.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments)), this;\n    },\n    on: function () {\n      return this.__$emitterPublic.on.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments)), this;\n    },\n    one: function () {\n      return this.__$emitterPublic.one.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments)), this;\n    },\n    origins: function (b) {\n      var c = b ? b + \" \" : \"\";\n      return a(c + \".tooltipstered\").toArray();\n    },\n    setDefaults: function (b) {\n      return a.extend(f, b), this;\n    },\n    triggerHandler: function () {\n      return this.__$emitterPublic.triggerHandler.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments)), this;\n    }\n  }, a.tooltipster = new i(), a.Tooltipster = function (b, c) {\n    this.__callbacks = {\n      close: [],\n      open: []\n    }, this.__closingTime, this.__Content, this.__contentBcr, this.__destroyed = !1, this.__$emitterPrivate = a({}), this.__$emitterPublic = a({}), this.__enabled = !0, this.__garbageCollector, this.__Geometry, this.__lastPosition, this.__namespace = \"tooltipster-\" + Math.round(1e6 * Math.random()), this.__options, this.__$originParents, this.__pointerIsOverOrigin = !1, this.__previousThemes = [], this.__state = \"closed\", this.__timeouts = {\n      close: [],\n      open: null\n    }, this.__touchEvents = [], this.__tracker = null, this._$origin, this._$tooltip, this.__init(b, c);\n  }, a.Tooltipster.prototype = {\n    __init: function (b, c) {\n      var d = this;\n\n      if (d._$origin = a(b), d.__options = a.extend(!0, {}, f, c), d.__optionsFormat(), !h.IE || h.IE >= d.__options.IEmin) {\n        var e = null;\n        if (void 0 === d._$origin.data(\"tooltipster-initialTitle\") && (e = d._$origin.attr(\"title\"), void 0 === e && (e = null), d._$origin.data(\"tooltipster-initialTitle\", e)), null !== d.__options.content) d.__contentSet(d.__options.content);else {\n          var g,\n              i = d._$origin.attr(\"data-tooltip-content\");\n\n          i && (g = a(i)), g && g[0] ? d.__contentSet(g.first()) : d.__contentSet(e);\n        }\n        d._$origin.removeAttr(\"title\").addClass(\"tooltipstered\"), d.__prepareOrigin(), d.__prepareGC(), a.each(d.__options.plugins, function (a, b) {\n          d._plug(b);\n        }), h.hasTouchCapability && a(h.window.document.body).on(\"touchmove.\" + d.__namespace + \"-triggerOpen\", function (a) {\n          d._touchRecordEvent(a);\n        }), d._on(\"created\", function () {\n          d.__prepareTooltip();\n        })._on(\"repositioned\", function (a) {\n          d.__lastPosition = a.position;\n        });\n      } else d.__options.disabled = !0;\n    },\n    __contentInsert: function () {\n      var a = this,\n          b = a._$tooltip.find(\".tooltipster-content\"),\n          c = a.__Content,\n          d = function (a) {\n        c = a;\n      };\n\n      return a._trigger({\n        type: \"format\",\n        content: a.__Content,\n        format: d\n      }), a.__options.functionFormat && (c = a.__options.functionFormat.call(a, a, {\n        origin: a._$origin[0]\n      }, a.__Content)), \"string\" != typeof c || a.__options.contentAsHTML ? b.empty().append(c) : b.text(c), a;\n    },\n    __contentSet: function (b) {\n      return b instanceof a && this.__options.contentCloning && (b = b.clone(!0)), this.__Content = b, this._trigger({\n        type: \"updated\",\n        content: b\n      }), this;\n    },\n    __destroyError: function () {\n      throw new Error(\"This tooltip has been destroyed and cannot execute your method call.\");\n    },\n    __geometry: function () {\n      var b = this,\n          c = b._$origin,\n          d = b._$origin.is(\"area\");\n\n      if (d) {\n        var e = b._$origin.parent().attr(\"name\");\n\n        c = a('img[usemap=\"#' + e + '\"]');\n      }\n\n      var f = c[0].getBoundingClientRect(),\n          g = a(h.window.document),\n          i = a(h.window),\n          j = c,\n          k = {\n        available: {\n          document: null,\n          window: null\n        },\n        document: {\n          size: {\n            height: g.height(),\n            width: g.width()\n          }\n        },\n        window: {\n          scroll: {\n            left: h.window.scrollX || h.window.document.documentElement.scrollLeft,\n            top: h.window.scrollY || h.window.document.documentElement.scrollTop\n          },\n          size: {\n            height: i.height(),\n            width: i.width()\n          }\n        },\n        origin: {\n          fixedLineage: !1,\n          offset: {},\n          size: {\n            height: f.bottom - f.top,\n            width: f.right - f.left\n          },\n          usemapImage: d ? c[0] : null,\n          windowOffset: {\n            bottom: f.bottom,\n            left: f.left,\n            right: f.right,\n            top: f.top\n          }\n        }\n      };\n\n      if (d) {\n        var l = b._$origin.attr(\"shape\"),\n            m = b._$origin.attr(\"coords\");\n\n        if (m && (m = m.split(\",\"), a.map(m, function (a, b) {\n          m[b] = parseInt(a);\n        })), \"default\" != l) switch (l) {\n          case \"circle\":\n            var n = m[0],\n                o = m[1],\n                p = m[2],\n                q = o - p,\n                r = n - p;\n            k.origin.size.height = 2 * p, k.origin.size.width = k.origin.size.height, k.origin.windowOffset.left += r, k.origin.windowOffset.top += q;\n            break;\n\n          case \"rect\":\n            var s = m[0],\n                t = m[1],\n                u = m[2],\n                v = m[3];\n            k.origin.size.height = v - t, k.origin.size.width = u - s, k.origin.windowOffset.left += s, k.origin.windowOffset.top += t;\n            break;\n\n          case \"poly\":\n            for (var w = 0, x = 0, y = 0, z = 0, A = \"even\", B = 0; B < m.length; B++) {\n              var C = m[B];\n              \"even\" == A ? (C > y && (y = C, 0 === B && (w = y)), w > C && (w = C), A = \"odd\") : (C > z && (z = C, 1 == B && (x = z)), x > C && (x = C), A = \"even\");\n            }\n\n            k.origin.size.height = z - x, k.origin.size.width = y - w, k.origin.windowOffset.left += w, k.origin.windowOffset.top += x;\n        }\n      }\n\n      var D = function (a) {\n        k.origin.size.height = a.height, k.origin.windowOffset.left = a.left, k.origin.windowOffset.top = a.top, k.origin.size.width = a.width;\n      };\n\n      for (b._trigger({\n        type: \"geometry\",\n        edit: D,\n        geometry: {\n          height: k.origin.size.height,\n          left: k.origin.windowOffset.left,\n          top: k.origin.windowOffset.top,\n          width: k.origin.size.width\n        }\n      }), k.origin.windowOffset.right = k.origin.windowOffset.left + k.origin.size.width, k.origin.windowOffset.bottom = k.origin.windowOffset.top + k.origin.size.height, k.origin.offset.left = k.origin.windowOffset.left + k.window.scroll.left, k.origin.offset.top = k.origin.windowOffset.top + k.window.scroll.top, k.origin.offset.bottom = k.origin.offset.top + k.origin.size.height, k.origin.offset.right = k.origin.offset.left + k.origin.size.width, k.available.document = {\n        bottom: {\n          height: k.document.size.height - k.origin.offset.bottom,\n          width: k.document.size.width\n        },\n        left: {\n          height: k.document.size.height,\n          width: k.origin.offset.left\n        },\n        right: {\n          height: k.document.size.height,\n          width: k.document.size.width - k.origin.offset.right\n        },\n        top: {\n          height: k.origin.offset.top,\n          width: k.document.size.width\n        }\n      }, k.available.window = {\n        bottom: {\n          height: Math.max(k.window.size.height - Math.max(k.origin.windowOffset.bottom, 0), 0),\n          width: k.window.size.width\n        },\n        left: {\n          height: k.window.size.height,\n          width: Math.max(k.origin.windowOffset.left, 0)\n        },\n        right: {\n          height: k.window.size.height,\n          width: Math.max(k.window.size.width - Math.max(k.origin.windowOffset.right, 0), 0)\n        },\n        top: {\n          height: Math.max(k.origin.windowOffset.top, 0),\n          width: k.window.size.width\n        }\n      }; \"html\" != j[0].tagName.toLowerCase();) {\n        if (\"fixed\" == j.css(\"position\")) {\n          k.origin.fixedLineage = !0;\n          break;\n        }\n\n        j = j.parent();\n      }\n\n      return k;\n    },\n    __optionsFormat: function () {\n      return \"number\" == typeof this.__options.animationDuration && (this.__options.animationDuration = [this.__options.animationDuration, this.__options.animationDuration]), \"number\" == typeof this.__options.delay && (this.__options.delay = [this.__options.delay, this.__options.delay]), \"number\" == typeof this.__options.delayTouch && (this.__options.delayTouch = [this.__options.delayTouch, this.__options.delayTouch]), \"string\" == typeof this.__options.theme && (this.__options.theme = [this.__options.theme]), null === this.__options.parent ? this.__options.parent = a(h.window.document.body) : \"string\" == typeof this.__options.parent && (this.__options.parent = a(this.__options.parent)), \"hover\" == this.__options.trigger ? (this.__options.triggerOpen = {\n        mouseenter: !0,\n        touchstart: !0\n      }, this.__options.triggerClose = {\n        mouseleave: !0,\n        originClick: !0,\n        touchleave: !0\n      }) : \"click\" == this.__options.trigger && (this.__options.triggerOpen = {\n        click: !0,\n        tap: !0\n      }, this.__options.triggerClose = {\n        click: !0,\n        tap: !0\n      }), this._trigger(\"options\"), this;\n    },\n    __prepareGC: function () {\n      var b = this;\n      return b.__options.selfDestruction ? b.__garbageCollector = setInterval(function () {\n        var c = new Date().getTime();\n        b.__touchEvents = a.grep(b.__touchEvents, function (a, b) {\n          return c - a.time > 6e4;\n        }), d(b._$origin) || b.close(function () {\n          b.destroy();\n        });\n      }, 2e4) : clearInterval(b.__garbageCollector), b;\n    },\n    __prepareOrigin: function () {\n      var a = this;\n\n      if (a._$origin.off(\".\" + a.__namespace + \"-triggerOpen\"), h.hasTouchCapability && a._$origin.on(\"touchstart.\" + a.__namespace + \"-triggerOpen touchend.\" + a.__namespace + \"-triggerOpen touchcancel.\" + a.__namespace + \"-triggerOpen\", function (b) {\n        a._touchRecordEvent(b);\n      }), a.__options.triggerOpen.click || a.__options.triggerOpen.tap && h.hasTouchCapability) {\n        var b = \"\";\n        a.__options.triggerOpen.click && (b += \"click.\" + a.__namespace + \"-triggerOpen \"), a.__options.triggerOpen.tap && h.hasTouchCapability && (b += \"touchend.\" + a.__namespace + \"-triggerOpen\"), a._$origin.on(b, function (b) {\n          a._touchIsMeaningfulEvent(b) && a._open(b);\n        });\n      }\n\n      if (a.__options.triggerOpen.mouseenter || a.__options.triggerOpen.touchstart && h.hasTouchCapability) {\n        var b = \"\";\n        a.__options.triggerOpen.mouseenter && (b += \"mouseenter.\" + a.__namespace + \"-triggerOpen \"), a.__options.triggerOpen.touchstart && h.hasTouchCapability && (b += \"touchstart.\" + a.__namespace + \"-triggerOpen\"), a._$origin.on(b, function (b) {\n          !a._touchIsTouchEvent(b) && a._touchIsEmulatedEvent(b) || (a.__pointerIsOverOrigin = !0, a._openShortly(b));\n        });\n      }\n\n      if (a.__options.triggerClose.mouseleave || a.__options.triggerClose.touchleave && h.hasTouchCapability) {\n        var b = \"\";\n        a.__options.triggerClose.mouseleave && (b += \"mouseleave.\" + a.__namespace + \"-triggerOpen \"), a.__options.triggerClose.touchleave && h.hasTouchCapability && (b += \"touchend.\" + a.__namespace + \"-triggerOpen touchcancel.\" + a.__namespace + \"-triggerOpen\"), a._$origin.on(b, function (b) {\n          a._touchIsMeaningfulEvent(b) && (a.__pointerIsOverOrigin = !1);\n        });\n      }\n\n      return a;\n    },\n    __prepareTooltip: function () {\n      var b = this,\n          c = b.__options.interactive ? \"auto\" : \"\";\n      return b._$tooltip.attr(\"id\", b.__namespace).css({\n        \"pointer-events\": c,\n        zIndex: b.__options.zIndex\n      }), a.each(b.__previousThemes, function (a, c) {\n        b._$tooltip.removeClass(c);\n      }), a.each(b.__options.theme, function (a, c) {\n        b._$tooltip.addClass(c);\n      }), b.__previousThemes = a.merge([], b.__options.theme), b;\n    },\n    __scrollHandler: function (b) {\n      var c = this;\n      if (c.__options.triggerClose.scroll) c._close(b);else if (d(c._$origin) && d(c._$tooltip)) {\n        var e = null;\n        if (b.target === h.window.document) c.__Geometry.origin.fixedLineage || c.__options.repositionOnScroll && c.reposition(b);else {\n          e = c.__geometry();\n          var f = !1;\n          if (\"fixed\" != c._$origin.css(\"position\") && c.__$originParents.each(function (b, c) {\n            var d = a(c),\n                g = d.css(\"overflow-x\"),\n                h = d.css(\"overflow-y\");\n\n            if (\"visible\" != g || \"visible\" != h) {\n              var i = c.getBoundingClientRect();\n              if (\"visible\" != g && (e.origin.windowOffset.left < i.left || e.origin.windowOffset.right > i.right)) return f = !0, !1;\n              if (\"visible\" != h && (e.origin.windowOffset.top < i.top || e.origin.windowOffset.bottom > i.bottom)) return f = !0, !1;\n            }\n\n            return \"fixed\" == d.css(\"position\") ? !1 : void 0;\n          }), f) c._$tooltip.css(\"visibility\", \"hidden\");else if (c._$tooltip.css(\"visibility\", \"visible\"), c.__options.repositionOnScroll) c.reposition(b);else {\n            var g = e.origin.offset.left - c.__Geometry.origin.offset.left,\n                i = e.origin.offset.top - c.__Geometry.origin.offset.top;\n\n            c._$tooltip.css({\n              left: c.__lastPosition.coord.left + g,\n              top: c.__lastPosition.coord.top + i\n            });\n          }\n        }\n\n        c._trigger({\n          type: \"scroll\",\n          event: b,\n          geo: e\n        });\n      }\n      return c;\n    },\n    __stateSet: function (a) {\n      return this.__state = a, this._trigger({\n        type: \"state\",\n        state: a\n      }), this;\n    },\n    __timeoutsClear: function () {\n      return clearTimeout(this.__timeouts.open), this.__timeouts.open = null, a.each(this.__timeouts.close, function (a, b) {\n        clearTimeout(b);\n      }), this.__timeouts.close = [], this;\n    },\n    __trackerStart: function () {\n      var a = this,\n          b = a._$tooltip.find(\".tooltipster-content\");\n\n      return a.__options.trackTooltip && (a.__contentBcr = b[0].getBoundingClientRect()), a.__tracker = setInterval(function () {\n        if (d(a._$origin) && d(a._$tooltip)) {\n          if (a.__options.trackOrigin) {\n            var e = a.__geometry(),\n                f = !1;\n\n            c(e.origin.size, a.__Geometry.origin.size) && (a.__Geometry.origin.fixedLineage ? c(e.origin.windowOffset, a.__Geometry.origin.windowOffset) && (f = !0) : c(e.origin.offset, a.__Geometry.origin.offset) && (f = !0)), f || (a.__options.triggerClose.mouseleave ? a._close() : a.reposition());\n          }\n\n          if (a.__options.trackTooltip) {\n            var g = b[0].getBoundingClientRect();\n            g.height === a.__contentBcr.height && g.width === a.__contentBcr.width || (a.reposition(), a.__contentBcr = g);\n          }\n        } else a._close();\n      }, a.__options.trackerInterval), a;\n    },\n    _close: function (b, c, d) {\n      var e = this,\n          f = !0;\n\n      if (e._trigger({\n        type: \"close\",\n        event: b,\n        stop: function () {\n          f = !1;\n        }\n      }), f || d) {\n        c && e.__callbacks.close.push(c), e.__callbacks.open = [], e.__timeoutsClear();\n\n        var g = function () {\n          a.each(e.__callbacks.close, function (a, c) {\n            c.call(e, e, {\n              event: b,\n              origin: e._$origin[0]\n            });\n          }), e.__callbacks.close = [];\n        };\n\n        if (\"closed\" != e.__state) {\n          var i = !0,\n              j = new Date(),\n              k = j.getTime(),\n              l = k + e.__options.animationDuration[1];\n\n          if (\"disappearing\" == e.__state && l > e.__closingTime && e.__options.animationDuration[1] > 0 && (i = !1), i) {\n            e.__closingTime = l, \"disappearing\" != e.__state && e.__stateSet(\"disappearing\");\n\n            var m = function () {\n              clearInterval(e.__tracker), e._trigger({\n                type: \"closing\",\n                event: b\n              }), e._$tooltip.off(\".\" + e.__namespace + \"-triggerClose\").removeClass(\"tooltipster-dying\"), a(h.window).off(\".\" + e.__namespace + \"-triggerClose\"), e.__$originParents.each(function (b, c) {\n                a(c).off(\"scroll.\" + e.__namespace + \"-triggerClose\");\n              }), e.__$originParents = null, a(h.window.document.body).off(\".\" + e.__namespace + \"-triggerClose\"), e._$origin.off(\".\" + e.__namespace + \"-triggerClose\"), e._off(\"dismissable\"), e.__stateSet(\"closed\"), e._trigger({\n                type: \"after\",\n                event: b\n              }), e.__options.functionAfter && e.__options.functionAfter.call(e, e, {\n                event: b,\n                origin: e._$origin[0]\n              }), g();\n            };\n\n            h.hasTransitions ? (e._$tooltip.css({\n              \"-moz-animation-duration\": e.__options.animationDuration[1] + \"ms\",\n              \"-ms-animation-duration\": e.__options.animationDuration[1] + \"ms\",\n              \"-o-animation-duration\": e.__options.animationDuration[1] + \"ms\",\n              \"-webkit-animation-duration\": e.__options.animationDuration[1] + \"ms\",\n              \"animation-duration\": e.__options.animationDuration[1] + \"ms\",\n              \"transition-duration\": e.__options.animationDuration[1] + \"ms\"\n            }), e._$tooltip.clearQueue().removeClass(\"tooltipster-show\").addClass(\"tooltipster-dying\"), e.__options.animationDuration[1] > 0 && e._$tooltip.delay(e.__options.animationDuration[1]), e._$tooltip.queue(m)) : e._$tooltip.stop().fadeOut(e.__options.animationDuration[1], m);\n          }\n        } else g();\n      }\n\n      return e;\n    },\n    _off: function () {\n      return this.__$emitterPrivate.off.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments)), this;\n    },\n    _on: function () {\n      return this.__$emitterPrivate.on.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments)), this;\n    },\n    _one: function () {\n      return this.__$emitterPrivate.one.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments)), this;\n    },\n    _open: function (b, c) {\n      var e = this;\n\n      if (!e.__destroying && d(e._$origin) && e.__enabled) {\n        var f = !0;\n\n        if (\"closed\" == e.__state && (e._trigger({\n          type: \"before\",\n          event: b,\n          stop: function () {\n            f = !1;\n          }\n        }), f && e.__options.functionBefore && (f = e.__options.functionBefore.call(e, e, {\n          event: b,\n          origin: e._$origin[0]\n        }))), f !== !1 && null !== e.__Content) {\n          c && e.__callbacks.open.push(c), e.__callbacks.close = [], e.__timeoutsClear();\n\n          var g,\n              i = function () {\n            \"stable\" != e.__state && e.__stateSet(\"stable\"), a.each(e.__callbacks.open, function (a, b) {\n              b.call(e, e, {\n                origin: e._$origin[0],\n                tooltip: e._$tooltip[0]\n              });\n            }), e.__callbacks.open = [];\n          };\n\n          if (\"closed\" !== e.__state) g = 0, \"disappearing\" === e.__state ? (e.__stateSet(\"appearing\"), h.hasTransitions ? (e._$tooltip.clearQueue().removeClass(\"tooltipster-dying\").addClass(\"tooltipster-show\"), e.__options.animationDuration[0] > 0 && e._$tooltip.delay(e.__options.animationDuration[0]), e._$tooltip.queue(i)) : e._$tooltip.stop().fadeIn(i)) : \"stable\" == e.__state && i();else {\n            if (e.__stateSet(\"appearing\"), g = e.__options.animationDuration[0], e.__contentInsert(), e.reposition(b, !0), h.hasTransitions ? (e._$tooltip.addClass(\"tooltipster-\" + e.__options.animation).addClass(\"tooltipster-initial\").css({\n              \"-moz-animation-duration\": e.__options.animationDuration[0] + \"ms\",\n              \"-ms-animation-duration\": e.__options.animationDuration[0] + \"ms\",\n              \"-o-animation-duration\": e.__options.animationDuration[0] + \"ms\",\n              \"-webkit-animation-duration\": e.__options.animationDuration[0] + \"ms\",\n              \"animation-duration\": e.__options.animationDuration[0] + \"ms\",\n              \"transition-duration\": e.__options.animationDuration[0] + \"ms\"\n            }), setTimeout(function () {\n              \"closed\" != e.__state && (e._$tooltip.addClass(\"tooltipster-show\").removeClass(\"tooltipster-initial\"), e.__options.animationDuration[0] > 0 && e._$tooltip.delay(e.__options.animationDuration[0]), e._$tooltip.queue(i));\n            }, 0)) : e._$tooltip.css(\"display\", \"none\").fadeIn(e.__options.animationDuration[0], i), e.__trackerStart(), a(h.window).on(\"resize.\" + e.__namespace + \"-triggerClose\", function (b) {\n              var c = a(document.activeElement);\n              (c.is(\"input\") || c.is(\"textarea\")) && a.contains(e._$tooltip[0], c[0]) || e.reposition(b);\n            }).on(\"scroll.\" + e.__namespace + \"-triggerClose\", function (a) {\n              e.__scrollHandler(a);\n            }), e.__$originParents = e._$origin.parents(), e.__$originParents.each(function (b, c) {\n              a(c).on(\"scroll.\" + e.__namespace + \"-triggerClose\", function (a) {\n                e.__scrollHandler(a);\n              });\n            }), e.__options.triggerClose.mouseleave || e.__options.triggerClose.touchleave && h.hasTouchCapability) {\n              e._on(\"dismissable\", function (a) {\n                a.dismissable ? a.delay ? (m = setTimeout(function () {\n                  e._close(a.event);\n                }, a.delay), e.__timeouts.close.push(m)) : e._close(a) : clearTimeout(m);\n              });\n\n              var j = e._$origin,\n                  k = \"\",\n                  l = \"\",\n                  m = null;\n              e.__options.interactive && (j = j.add(e._$tooltip)), e.__options.triggerClose.mouseleave && (k += \"mouseenter.\" + e.__namespace + \"-triggerClose \", l += \"mouseleave.\" + e.__namespace + \"-triggerClose \"), e.__options.triggerClose.touchleave && h.hasTouchCapability && (k += \"touchstart.\" + e.__namespace + \"-triggerClose\", l += \"touchend.\" + e.__namespace + \"-triggerClose touchcancel.\" + e.__namespace + \"-triggerClose\"), j.on(l, function (a) {\n                if (e._touchIsTouchEvent(a) || !e._touchIsEmulatedEvent(a)) {\n                  var b = \"mouseleave\" == a.type ? e.__options.delay : e.__options.delayTouch;\n\n                  e._trigger({\n                    delay: b[1],\n                    dismissable: !0,\n                    event: a,\n                    type: \"dismissable\"\n                  });\n                }\n              }).on(k, function (a) {\n                !e._touchIsTouchEvent(a) && e._touchIsEmulatedEvent(a) || e._trigger({\n                  dismissable: !1,\n                  event: a,\n                  type: \"dismissable\"\n                });\n              });\n            }\n\n            e.__options.triggerClose.originClick && e._$origin.on(\"click.\" + e.__namespace + \"-triggerClose\", function (a) {\n              e._touchIsTouchEvent(a) || e._touchIsEmulatedEvent(a) || e._close(a);\n            }), (e.__options.triggerClose.click || e.__options.triggerClose.tap && h.hasTouchCapability) && setTimeout(function () {\n              if (\"closed\" != e.__state) {\n                var b = \"\",\n                    c = a(h.window.document.body);\n                e.__options.triggerClose.click && (b += \"click.\" + e.__namespace + \"-triggerClose \"), e.__options.triggerClose.tap && h.hasTouchCapability && (b += \"touchend.\" + e.__namespace + \"-triggerClose\"), c.on(b, function (b) {\n                  e._touchIsMeaningfulEvent(b) && (e._touchRecordEvent(b), e.__options.interactive && a.contains(e._$tooltip[0], b.target) || e._close(b));\n                }), e.__options.triggerClose.tap && h.hasTouchCapability && c.on(\"touchstart.\" + e.__namespace + \"-triggerClose\", function (a) {\n                  e._touchRecordEvent(a);\n                });\n              }\n            }, 0), e._trigger(\"ready\"), e.__options.functionReady && e.__options.functionReady.call(e, e, {\n              origin: e._$origin[0],\n              tooltip: e._$tooltip[0]\n            });\n          }\n\n          if (e.__options.timer > 0) {\n            var m = setTimeout(function () {\n              e._close();\n            }, e.__options.timer + g);\n\n            e.__timeouts.close.push(m);\n          }\n        }\n      }\n\n      return e;\n    },\n    _openShortly: function (a) {\n      var b = this,\n          c = !0;\n\n      if (\"stable\" != b.__state && \"appearing\" != b.__state && !b.__timeouts.open && (b._trigger({\n        type: \"start\",\n        event: a,\n        stop: function () {\n          c = !1;\n        }\n      }), c)) {\n        var d = 0 == a.type.indexOf(\"touch\") ? b.__options.delayTouch : b.__options.delay;\n        d[0] ? b.__timeouts.open = setTimeout(function () {\n          b.__timeouts.open = null, b.__pointerIsOverOrigin && b._touchIsMeaningfulEvent(a) ? (b._trigger(\"startend\"), b._open(a)) : b._trigger(\"startcancel\");\n        }, d[0]) : (b._trigger(\"startend\"), b._open(a));\n      }\n\n      return b;\n    },\n    _optionsExtract: function (b, c) {\n      var d = this,\n          e = a.extend(!0, {}, c),\n          f = d.__options[b];\n      return f || (f = {}, a.each(c, function (a, b) {\n        var c = d.__options[a];\n        void 0 !== c && (f[a] = c);\n      })), a.each(e, function (b, c) {\n        void 0 !== f[b] && (\"object\" != typeof c || c instanceof Array || null == c || \"object\" != typeof f[b] || f[b] instanceof Array || null == f[b] ? e[b] = f[b] : a.extend(e[b], f[b]));\n      }), e;\n    },\n    _plug: function (b) {\n      var c = a.tooltipster._plugin(b);\n\n      if (!c) throw new Error('The \"' + b + '\" plugin is not defined');\n      return c.instance && a.tooltipster.__bridge(c.instance, this, c.name), this;\n    },\n    _touchIsEmulatedEvent: function (a) {\n      for (var b = !1, c = new Date().getTime(), d = this.__touchEvents.length - 1; d >= 0; d--) {\n        var e = this.__touchEvents[d];\n        if (!(c - e.time < 500)) break;\n        e.target === a.target && (b = !0);\n      }\n\n      return b;\n    },\n    _touchIsMeaningfulEvent: function (a) {\n      return this._touchIsTouchEvent(a) && !this._touchSwiped(a.target) || !this._touchIsTouchEvent(a) && !this._touchIsEmulatedEvent(a);\n    },\n    _touchIsTouchEvent: function (a) {\n      return 0 == a.type.indexOf(\"touch\");\n    },\n    _touchRecordEvent: function (a) {\n      return this._touchIsTouchEvent(a) && (a.time = new Date().getTime(), this.__touchEvents.push(a)), this;\n    },\n    _touchSwiped: function (a) {\n      for (var b = !1, c = this.__touchEvents.length - 1; c >= 0; c--) {\n        var d = this.__touchEvents[c];\n\n        if (\"touchmove\" == d.type) {\n          b = !0;\n          break;\n        }\n\n        if (\"touchstart\" == d.type && a === d.target) break;\n      }\n\n      return b;\n    },\n    _trigger: function () {\n      var b = Array.prototype.slice.apply(arguments);\n      return \"string\" == typeof b[0] && (b[0] = {\n        type: b[0]\n      }), b[0].instance = this, b[0].origin = this._$origin ? this._$origin[0] : null, b[0].tooltip = this._$tooltip ? this._$tooltip[0] : null, this.__$emitterPrivate.trigger.apply(this.__$emitterPrivate, b), a.tooltipster._trigger.apply(a.tooltipster, b), this.__$emitterPublic.trigger.apply(this.__$emitterPublic, b), this;\n    },\n    _unplug: function (b) {\n      var c = this;\n\n      if (c[b]) {\n        var d = a.tooltipster._plugin(b);\n\n        d.instance && a.each(d.instance, function (a, d) {\n          c[a] && c[a].bridged === c[b] && delete c[a];\n        }), c[b].__destroy && c[b].__destroy(), delete c[b];\n      }\n\n      return c;\n    },\n    close: function (a) {\n      return this.__destroyed ? this.__destroyError() : this._close(null, a), this;\n    },\n    content: function (a) {\n      var b = this;\n      if (void 0 === a) return b.__Content;\n      if (b.__destroyed) b.__destroyError();else if (b.__contentSet(a), null !== b.__Content) {\n        if (\"closed\" !== b.__state && (b.__contentInsert(), b.reposition(), b.__options.updateAnimation)) if (h.hasTransitions) {\n          var c = b.__options.updateAnimation;\n          b._$tooltip.addClass(\"tooltipster-update-\" + c), setTimeout(function () {\n            \"closed\" != b.__state && b._$tooltip.removeClass(\"tooltipster-update-\" + c);\n          }, 1e3);\n        } else b._$tooltip.fadeTo(200, .5, function () {\n          \"closed\" != b.__state && b._$tooltip.fadeTo(200, 1);\n        });\n      } else b._close();\n      return b;\n    },\n    destroy: function () {\n      var b = this;\n      if (b.__destroyed) b.__destroyError();else {\n        \"closed\" != b.__state ? b.option(\"animationDuration\", 0)._close(null, null, !0) : b.__timeoutsClear(), b._trigger(\"destroy\"), b.__destroyed = !0, b._$origin.removeData(b.__namespace).off(\".\" + b.__namespace + \"-triggerOpen\"), a(h.window.document.body).off(\".\" + b.__namespace + \"-triggerOpen\");\n\n        var c = b._$origin.data(\"tooltipster-ns\");\n\n        if (c) if (1 === c.length) {\n          var d = null;\n          \"previous\" == b.__options.restoration ? d = b._$origin.data(\"tooltipster-initialTitle\") : \"current\" == b.__options.restoration && (d = \"string\" == typeof b.__Content ? b.__Content : a(\"<div></div>\").append(b.__Content).html()), d && b._$origin.attr(\"title\", d), b._$origin.removeClass(\"tooltipstered\"), b._$origin.removeData(\"tooltipster-ns\").removeData(\"tooltipster-initialTitle\");\n        } else c = a.grep(c, function (a, c) {\n          return a !== b.__namespace;\n        }), b._$origin.data(\"tooltipster-ns\", c);\n        b._trigger(\"destroyed\"), b._off(), b.off(), b.__Content = null, b.__$emitterPrivate = null, b.__$emitterPublic = null, b.__options.parent = null, b._$origin = null, b._$tooltip = null, a.tooltipster.__instancesLatestArr = a.grep(a.tooltipster.__instancesLatestArr, function (a, c) {\n          return b !== a;\n        }), clearInterval(b.__garbageCollector);\n      }\n      return b;\n    },\n    disable: function () {\n      return this.__destroyed ? (this.__destroyError(), this) : (this._close(), this.__enabled = !1, this);\n    },\n    elementOrigin: function () {\n      return this.__destroyed ? void this.__destroyError() : this._$origin[0];\n    },\n    elementTooltip: function () {\n      return this._$tooltip ? this._$tooltip[0] : null;\n    },\n    enable: function () {\n      return this.__enabled = !0, this;\n    },\n    hide: function (a) {\n      return this.close(a);\n    },\n    instance: function () {\n      return this;\n    },\n    off: function () {\n      return this.__destroyed || this.__$emitterPublic.off.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments)), this;\n    },\n    on: function () {\n      return this.__destroyed ? this.__destroyError() : this.__$emitterPublic.on.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments)), this;\n    },\n    one: function () {\n      return this.__destroyed ? this.__destroyError() : this.__$emitterPublic.one.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments)), this;\n    },\n    open: function (a) {\n      return this.__destroyed ? this.__destroyError() : this._open(null, a), this;\n    },\n    option: function (b, c) {\n      return void 0 === c ? this.__options[b] : (this.__destroyed ? this.__destroyError() : (this.__options[b] = c, this.__optionsFormat(), a.inArray(b, [\"trigger\", \"triggerClose\", \"triggerOpen\"]) >= 0 && this.__prepareOrigin(), \"selfDestruction\" === b && this.__prepareGC()), this);\n    },\n    reposition: function (a, b) {\n      var c = this;\n      return c.__destroyed ? c.__destroyError() : \"closed\" != c.__state && d(c._$origin) && (b || d(c._$tooltip)) && (b || c._$tooltip.detach(), c.__Geometry = c.__geometry(), c._trigger({\n        type: \"reposition\",\n        event: a,\n        helper: {\n          geo: c.__Geometry\n        }\n      })), c;\n    },\n    show: function (a) {\n      return this.open(a);\n    },\n    status: function () {\n      return {\n        destroyed: this.__destroyed,\n        enabled: this.__enabled,\n        open: \"closed\" !== this.__state,\n        state: this.__state\n      };\n    },\n    triggerHandler: function () {\n      return this.__destroyed ? this.__destroyError() : this.__$emitterPublic.triggerHandler.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments)), this;\n    }\n  }, a.fn.tooltipster = function () {\n    var b = Array.prototype.slice.apply(arguments),\n        c = \"You are using a single HTML element as content for several tooltips. You probably want to set the contentCloning option to TRUE.\";\n    if (0 === this.length) return this;\n\n    if (\"string\" == typeof b[0]) {\n      var d = \"#*$~&\";\n      return this.each(function () {\n        var e = a(this).data(\"tooltipster-ns\"),\n            f = e ? a(this).data(e[0]) : null;\n        if (!f) throw new Error(\"You called Tooltipster's \\\"\" + b[0] + '\" method on an uninitialized element');\n        if (\"function\" != typeof f[b[0]]) throw new Error('Unknown method \"' + b[0] + '\"');\n        this.length > 1 && \"content\" == b[0] && (b[1] instanceof a || \"object\" == typeof b[1] && null != b[1] && b[1].tagName) && !f.__options.contentCloning && f.__options.debug && console.log(c);\n        var g = f[b[0]](b[1], b[2]);\n        return g !== f || \"instance\" === b[0] ? (d = g, !1) : void 0;\n      }), \"#*$~&\" !== d ? d : this;\n    }\n\n    a.tooltipster.__instancesLatestArr = [];\n    var e = b[0] && void 0 !== b[0].multiple,\n        g = e && b[0].multiple || !e && f.multiple,\n        h = b[0] && void 0 !== b[0].content,\n        i = h && b[0].content || !h && f.content,\n        j = b[0] && void 0 !== b[0].contentCloning,\n        k = j && b[0].contentCloning || !j && f.contentCloning,\n        l = b[0] && void 0 !== b[0].debug,\n        m = l && b[0].debug || !l && f.debug;\n    return this.length > 1 && (i instanceof a || \"object\" == typeof i && null != i && i.tagName) && !k && m && console.log(c), this.each(function () {\n      var c = !1,\n          d = a(this),\n          e = d.data(\"tooltipster-ns\"),\n          f = null;\n      e ? g ? c = !0 : m && (console.log(\"Tooltipster: one or more tooltips are already attached to the element below. Ignoring.\"), console.log(this)) : c = !0, c && (f = new a.Tooltipster(this, b[0]), e || (e = []), e.push(f.__namespace), d.data(\"tooltipster-ns\", e), d.data(f.__namespace, f), f.__options.functionInit && f.__options.functionInit.call(f, f, {\n        origin: this\n      }), f._trigger(\"init\")), a.tooltipster.__instancesLatestArr.push(f);\n    }), this;\n  }, b.prototype = {\n    __init: function (b) {\n      this.__$tooltip = b, this.__$tooltip.css({\n        left: 0,\n        overflow: \"hidden\",\n        position: \"absolute\",\n        top: 0\n      }).find(\".tooltipster-content\").css(\"overflow\", \"auto\"), this.$container = a('<div class=\"tooltipster-ruler\"></div>').append(this.__$tooltip).appendTo(h.window.document.body);\n    },\n    __forceRedraw: function () {\n      var a = this.__$tooltip.parent();\n\n      this.__$tooltip.detach(), this.__$tooltip.appendTo(a);\n    },\n    constrain: function (a, b) {\n      return this.constraints = {\n        width: a,\n        height: b\n      }, this.__$tooltip.css({\n        display: \"block\",\n        height: \"\",\n        overflow: \"auto\",\n        width: a\n      }), this;\n    },\n    destroy: function () {\n      this.__$tooltip.detach().find(\".tooltipster-content\").css({\n        display: \"\",\n        overflow: \"\"\n      }), this.$container.remove();\n    },\n    free: function () {\n      return this.constraints = null, this.__$tooltip.css({\n        display: \"\",\n        height: \"\",\n        overflow: \"visible\",\n        width: \"\"\n      }), this;\n    },\n    measure: function () {\n      this.__forceRedraw();\n\n      var a = this.__$tooltip[0].getBoundingClientRect(),\n          b = {\n        size: {\n          height: a.height || a.bottom - a.top,\n          width: a.width || a.right - a.left\n        }\n      };\n\n      if (this.constraints) {\n        var c = this.__$tooltip.find(\".tooltipster-content\"),\n            d = this.__$tooltip.outerHeight(),\n            e = c[0].getBoundingClientRect(),\n            f = {\n          height: d <= this.constraints.height,\n          width: a.width <= this.constraints.width && e.width >= c[0].scrollWidth - 1\n        };\n\n        b.fits = f.height && f.width;\n      }\n\n      return h.IE && h.IE <= 11 && b.size.width !== h.window.document.documentElement.clientWidth && (b.size.width = Math.ceil(b.size.width) + 1), b;\n    }\n  };\n  var j = navigator.userAgent.toLowerCase();\n  -1 != j.indexOf(\"msie\") ? h.IE = parseInt(j.split(\"msie\")[1]) : -1 !== j.toLowerCase().indexOf(\"trident\") && -1 !== j.indexOf(\" rv:11\") ? h.IE = 11 : -1 != j.toLowerCase().indexOf(\"edge/\") && (h.IE = parseInt(j.toLowerCase().split(\"edge/\")[1]));\n  var k = \"tooltipster.sideTip\";\n  return a.tooltipster._plugin({\n    name: k,\n    instance: {\n      __defaults: function () {\n        return {\n          arrow: !0,\n          distance: 6,\n          functionPosition: null,\n          maxWidth: null,\n          minIntersection: 16,\n          minWidth: 0,\n          position: null,\n          side: \"top\",\n          viewportAware: !0\n        };\n      },\n      __init: function (a) {\n        var b = this;\n        b.__instance = a, b.__namespace = \"tooltipster-sideTip-\" + Math.round(1e6 * Math.random()), b.__previousState = \"closed\", b.__options, b.__optionsFormat(), b.__instance._on(\"state.\" + b.__namespace, function (a) {\n          \"closed\" == a.state ? b.__close() : \"appearing\" == a.state && \"closed\" == b.__previousState && b.__create(), b.__previousState = a.state;\n        }), b.__instance._on(\"options.\" + b.__namespace, function () {\n          b.__optionsFormat();\n        }), b.__instance._on(\"reposition.\" + b.__namespace, function (a) {\n          b.__reposition(a.event, a.helper);\n        });\n      },\n      __close: function () {\n        this.__instance.content() instanceof a && this.__instance.content().detach(), this.__instance._$tooltip.remove(), this.__instance._$tooltip = null;\n      },\n      __create: function () {\n        var b = a('<div class=\"tooltipster-base tooltipster-sidetip\"><div class=\"tooltipster-box\"><div class=\"tooltipster-content\"></div></div><div class=\"tooltipster-arrow\"><div class=\"tooltipster-arrow-uncropped\"><div class=\"tooltipster-arrow-border\"></div><div class=\"tooltipster-arrow-background\"></div></div></div></div>');\n        this.__options.arrow || b.find(\".tooltipster-box\").css(\"margin\", 0).end().find(\".tooltipster-arrow\").hide(), this.__options.minWidth && b.css(\"min-width\", this.__options.minWidth + \"px\"), this.__options.maxWidth && b.css(\"max-width\", this.__options.maxWidth + \"px\"), this.__instance._$tooltip = b, this.__instance._trigger(\"created\");\n      },\n      __destroy: function () {\n        this.__instance._off(\".\" + self.__namespace);\n      },\n      __optionsFormat: function () {\n        var b = this;\n\n        if (b.__options = b.__instance._optionsExtract(k, b.__defaults()), b.__options.position && (b.__options.side = b.__options.position), \"object\" != typeof b.__options.distance && (b.__options.distance = [b.__options.distance]), b.__options.distance.length < 4 && (void 0 === b.__options.distance[1] && (b.__options.distance[1] = b.__options.distance[0]), void 0 === b.__options.distance[2] && (b.__options.distance[2] = b.__options.distance[0]), void 0 === b.__options.distance[3] && (b.__options.distance[3] = b.__options.distance[1]), b.__options.distance = {\n          top: b.__options.distance[0],\n          right: b.__options.distance[1],\n          bottom: b.__options.distance[2],\n          left: b.__options.distance[3]\n        }), \"string\" == typeof b.__options.side) {\n          var c = {\n            top: \"bottom\",\n            right: \"left\",\n            bottom: \"top\",\n            left: \"right\"\n          };\n          b.__options.side = [b.__options.side, c[b.__options.side]], \"left\" == b.__options.side[0] || \"right\" == b.__options.side[0] ? b.__options.side.push(\"top\", \"bottom\") : b.__options.side.push(\"right\", \"left\");\n        }\n\n        6 === a.tooltipster._env.IE && b.__options.arrow !== !0 && (b.__options.arrow = !1);\n      },\n      __reposition: function (b, c) {\n        var d,\n            e = this,\n            f = e.__targetFind(c),\n            g = [];\n\n        e.__instance._$tooltip.detach();\n\n        var h = e.__instance._$tooltip.clone(),\n            i = a.tooltipster._getRuler(h),\n            j = !1,\n            k = e.__instance.option(\"animation\");\n\n        switch (k && h.removeClass(\"tooltipster-\" + k), a.each([\"window\", \"document\"], function (d, k) {\n          var l = null;\n          if (e.__instance._trigger({\n            container: k,\n            helper: c,\n            satisfied: j,\n            takeTest: function (a) {\n              l = a;\n            },\n            results: g,\n            type: \"positionTest\"\n          }), 1 == l || 0 != l && 0 == j && (\"window\" != k || e.__options.viewportAware)) for (var d = 0; d < e.__options.side.length; d++) {\n            var m = {\n              horizontal: 0,\n              vertical: 0\n            },\n                n = e.__options.side[d];\n            \"top\" == n || \"bottom\" == n ? m.vertical = e.__options.distance[n] : m.horizontal = e.__options.distance[n], e.__sideChange(h, n), a.each([\"natural\", \"constrained\"], function (a, d) {\n              if (l = null, e.__instance._trigger({\n                container: k,\n                event: b,\n                helper: c,\n                mode: d,\n                results: g,\n                satisfied: j,\n                side: n,\n                takeTest: function (a) {\n                  l = a;\n                },\n                type: \"positionTest\"\n              }), 1 == l || 0 != l && 0 == j) {\n                var h = {\n                  container: k,\n                  distance: m,\n                  fits: null,\n                  mode: d,\n                  outerSize: null,\n                  side: n,\n                  size: null,\n                  target: f[n],\n                  whole: null\n                },\n                    o = \"natural\" == d ? i.free() : i.constrain(c.geo.available[k][n].width - m.horizontal, c.geo.available[k][n].height - m.vertical),\n                    p = o.measure();\n                if (h.size = p.size, h.outerSize = {\n                  height: p.size.height + m.vertical,\n                  width: p.size.width + m.horizontal\n                }, \"natural\" == d ? c.geo.available[k][n].width >= h.outerSize.width && c.geo.available[k][n].height >= h.outerSize.height ? h.fits = !0 : h.fits = !1 : h.fits = p.fits, \"window\" == k && (h.fits ? \"top\" == n || \"bottom\" == n ? h.whole = c.geo.origin.windowOffset.right >= e.__options.minIntersection && c.geo.window.size.width - c.geo.origin.windowOffset.left >= e.__options.minIntersection : h.whole = c.geo.origin.windowOffset.bottom >= e.__options.minIntersection && c.geo.window.size.height - c.geo.origin.windowOffset.top >= e.__options.minIntersection : h.whole = !1), g.push(h), h.whole) j = !0;else if (\"natural\" == h.mode && (h.fits || h.size.width <= c.geo.available[k][n].width)) return !1;\n              }\n            });\n          }\n        }), e.__instance._trigger({\n          edit: function (a) {\n            g = a;\n          },\n          event: b,\n          helper: c,\n          results: g,\n          type: \"positionTested\"\n        }), g.sort(function (a, b) {\n          if (a.whole && !b.whole) return -1;\n          if (!a.whole && b.whole) return 1;\n\n          if (a.whole && b.whole) {\n            var c = e.__options.side.indexOf(a.side),\n                d = e.__options.side.indexOf(b.side);\n\n            return d > c ? -1 : c > d ? 1 : \"natural\" == a.mode ? -1 : 1;\n          }\n\n          if (a.fits && !b.fits) return -1;\n          if (!a.fits && b.fits) return 1;\n\n          if (a.fits && b.fits) {\n            var c = e.__options.side.indexOf(a.side),\n                d = e.__options.side.indexOf(b.side);\n\n            return d > c ? -1 : c > d ? 1 : \"natural\" == a.mode ? -1 : 1;\n          }\n\n          return \"document\" == a.container && \"bottom\" == a.side && \"natural\" == a.mode ? -1 : 1;\n        }), d = g[0], d.coord = {}, d.side) {\n          case \"left\":\n          case \"right\":\n            d.coord.top = Math.floor(d.target - d.size.height / 2);\n            break;\n\n          case \"bottom\":\n          case \"top\":\n            d.coord.left = Math.floor(d.target - d.size.width / 2);\n        }\n\n        switch (d.side) {\n          case \"left\":\n            d.coord.left = c.geo.origin.windowOffset.left - d.outerSize.width;\n            break;\n\n          case \"right\":\n            d.coord.left = c.geo.origin.windowOffset.right + d.distance.horizontal;\n            break;\n\n          case \"top\":\n            d.coord.top = c.geo.origin.windowOffset.top - d.outerSize.height;\n            break;\n\n          case \"bottom\":\n            d.coord.top = c.geo.origin.windowOffset.bottom + d.distance.vertical;\n        }\n\n        \"window\" == d.container ? \"top\" == d.side || \"bottom\" == d.side ? d.coord.left < 0 ? c.geo.origin.windowOffset.right - this.__options.minIntersection >= 0 ? d.coord.left = 0 : d.coord.left = c.geo.origin.windowOffset.right - this.__options.minIntersection - 1 : d.coord.left > c.geo.window.size.width - d.size.width && (c.geo.origin.windowOffset.left + this.__options.minIntersection <= c.geo.window.size.width ? d.coord.left = c.geo.window.size.width - d.size.width : d.coord.left = c.geo.origin.windowOffset.left + this.__options.minIntersection + 1 - d.size.width) : d.coord.top < 0 ? c.geo.origin.windowOffset.bottom - this.__options.minIntersection >= 0 ? d.coord.top = 0 : d.coord.top = c.geo.origin.windowOffset.bottom - this.__options.minIntersection - 1 : d.coord.top > c.geo.window.size.height - d.size.height && (c.geo.origin.windowOffset.top + this.__options.minIntersection <= c.geo.window.size.height ? d.coord.top = c.geo.window.size.height - d.size.height : d.coord.top = c.geo.origin.windowOffset.top + this.__options.minIntersection + 1 - d.size.height) : (d.coord.left > c.geo.window.size.width - d.size.width && (d.coord.left = c.geo.window.size.width - d.size.width), d.coord.left < 0 && (d.coord.left = 0)), e.__sideChange(h, d.side), c.tooltipClone = h[0], c.tooltipParent = e.__instance.option(\"parent\").parent[0], c.mode = d.mode, c.whole = d.whole, c.origin = e.__instance._$origin[0], c.tooltip = e.__instance._$tooltip[0], delete d.container, delete d.fits, delete d.mode, delete d.outerSize, delete d.whole, d.distance = d.distance.horizontal || d.distance.vertical;\n        var l = a.extend(!0, {}, d);\n\n        if (e.__instance._trigger({\n          edit: function (a) {\n            d = a;\n          },\n          event: b,\n          helper: c,\n          position: l,\n          type: \"position\"\n        }), e.__options.functionPosition) {\n          var m = e.__options.functionPosition.call(e, e.__instance, c, l);\n\n          m && (d = m);\n        }\n\n        i.destroy();\n        var n, o;\n        \"top\" == d.side || \"bottom\" == d.side ? (n = {\n          prop: \"left\",\n          val: d.target - d.coord.left\n        }, o = d.size.width - this.__options.minIntersection) : (n = {\n          prop: \"top\",\n          val: d.target - d.coord.top\n        }, o = d.size.height - this.__options.minIntersection), n.val < this.__options.minIntersection ? n.val = this.__options.minIntersection : n.val > o && (n.val = o);\n        var p;\n        p = c.geo.origin.fixedLineage ? c.geo.origin.windowOffset : {\n          left: c.geo.origin.windowOffset.left + c.geo.window.scroll.left,\n          top: c.geo.origin.windowOffset.top + c.geo.window.scroll.top\n        }, d.coord = {\n          left: p.left + (d.coord.left - c.geo.origin.windowOffset.left),\n          top: p.top + (d.coord.top - c.geo.origin.windowOffset.top)\n        }, e.__sideChange(e.__instance._$tooltip, d.side), c.geo.origin.fixedLineage ? e.__instance._$tooltip.css(\"position\", \"fixed\") : e.__instance._$tooltip.css(\"position\", \"\"), e.__instance._$tooltip.css({\n          left: d.coord.left,\n          top: d.coord.top,\n          height: d.size.height,\n          width: d.size.width\n        }).find(\".tooltipster-arrow\").css({\n          left: \"\",\n          top: \"\"\n        }).css(n.prop, n.val), e.__instance._$tooltip.appendTo(e.__instance.option(\"parent\")), e.__instance._trigger({\n          type: \"repositioned\",\n          event: b,\n          position: d\n        });\n      },\n      __sideChange: function (a, b) {\n        a.removeClass(\"tooltipster-bottom\").removeClass(\"tooltipster-left\").removeClass(\"tooltipster-right\").removeClass(\"tooltipster-top\").addClass(\"tooltipster-\" + b);\n      },\n      __targetFind: function (a) {\n        var b = {},\n            c = this.__instance._$origin[0].getClientRects();\n\n        if (c.length > 1) {\n          var d = this.__instance._$origin.css(\"opacity\");\n\n          1 == d && (this.__instance._$origin.css(\"opacity\", .99), c = this.__instance._$origin[0].getClientRects(), this.__instance._$origin.css(\"opacity\", 1));\n        }\n\n        if (c.length < 2) b.top = Math.floor(a.geo.origin.windowOffset.left + a.geo.origin.size.width / 2), b.bottom = b.top, b.left = Math.floor(a.geo.origin.windowOffset.top + a.geo.origin.size.height / 2), b.right = b.left;else {\n          var e = c[0];\n          b.top = Math.floor(e.left + (e.right - e.left) / 2), e = c.length > 2 ? c[Math.ceil(c.length / 2) - 1] : c[0], b.right = Math.floor(e.top + (e.bottom - e.top) / 2), e = c[c.length - 1], b.bottom = Math.floor(e.left + (e.right - e.left) / 2), e = c.length > 2 ? c[Math.ceil((c.length + 1) / 2) - 1] : c[c.length - 1], b.left = Math.floor(e.top + (e.bottom - e.top) / 2);\n        }\n        return b;\n      }\n    }\n  }), a;\n});","map":null,"metadata":{},"sourceType":"script"}